# LANGUAGE PARADIGMS

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII

## ğŸ“Œ Programming paradigm

`paradigm` `TÃ¼rkÃ§esi`: paradigma

`paradigma` kelime anlamÄ±: 1-Ã¶rnek, 2-bir ÅŸeyin nasÄ±l Ã¼retileceÄŸi konusunda Ã¶rnek/model

programlama dilinin Ã¶zellikleridir: Ã¶rneÄŸin cephe yÃ¶nelimli olmasÄ±, object-oriented olmasÄ± birer paradigmadÄ±r.

## ğŸ“Œ multi-paradigm programming language

bazÄ± programlama dillerinin bazÄ± Ã¶zellikleri birden fazla paradigmayÄ± desteklemektedir.

## ğŸ“Œ programlama dilleri jenerasyonlarÄ±

- 1inci jenerasyon (1GL): 1 ve 0'lardan oluÅŸan programlama dilleridir. 2inci dÃ¼nya savaÅŸÄ±nda Nazi almanyasÄ±nÄ±n ÅŸifreli mesajlaÅŸma makinesi olan Enigma'yÄ± Ã§Ã¶zebilmek iÃ§in, Alen Turing, Turing makinesi ile 1940'larda ilk programlama mantÄ±ÄŸÄ± ortaya atÄ±lmÄ±ÅŸtÄ±r. Fakat programlama dilleri olmadÄ±ÄŸÄ± iÃ§in manyetik teypler panel aracÄ±lÄ±ÄŸÄ± ile kapatÄ±lÄ±p aÃ§Ä±lÄ±yordu (switch/toggle). bu ÅŸekilde sadece 1 ve 0'lar ile iÅŸlemler yapÄ±lÄ±yordu. Bu sebeple bu jenerasyonun dillerinde kodu Ã§evirmeye ihtiyaÃ§ yoktur. direk kod makinede iÅŸletilebilir durumdadÄ±r.

- 2inci jenerasyon (2GL): dÃ¼ÅŸÃ¼k seviyeli programlama dilleri. assembly. Ä°lk 1950'lerde ortaya Ã§Ä±kmÄ±ÅŸtÄ±r. Bu jenerasyonda temel yenilik, 1 ve 0'larÄ±n insanlar tarafÄ±ndan okunmasÄ±nÄ±n aÅŸÄ±rÄ± gereksiz ve zor olmasÄ±dÄ±r.

- 3inci jenerasyon (3GL): yÃ¼ksek seviyeli programlama dilleri. C, C++, C#, Java. Bu jenerasyonda temel yenilikler:
  - 2GL'nin daha Ã§ok cihazlara baÄŸlÄ± syntax'lar iÃ§ermesinden kurtulmak
  - daha human-readable bir syntax yapmak
  - byte Ã¼zerinden yÃ¶netilebilen yeni bÃ¼tÃ¼nleÅŸik veri tipleri oluÅŸturabilmek. Ã¶rnekler:
    - array
    - Class/obje
    - OS'un register'larÄ±nÄ±n desteklemediÄŸi bÃ¼yÃ¼klÃ¼kte sayÄ±lar

- 4inci jenerasyon (4GL): diÄŸer jenerasyondakiler gibi sadece bit, byte veya bunlarÄ±n Ã¼zerine kurulmuÅŸ temel veri tiplerini yÃ¶netmekle deÄŸil, direk olarak logical anlamda "veriler" kullanabilmektedirler. Ã¶rneÄŸin tablo Ã¼zerinde direk iÅŸlem saÄŸlanabilmekte, ve ekrana GUI raporu alÄ±nabilmektedir. Ã–rnekler: SPSS, Unix shell, SQL. BazÄ± araÅŸtÄ±rmacÄ±lar, bu jenerasyonun sadece DSL olduÄŸunu dÃ¼ÅŸÃ¼nmektedir. AraÅŸtÄ±rmacÄ±lar bu jenerasyonun domain'e Ã¶zel geliÅŸtirilen bir dil olduÄŸunu dÃ¼ÅŸÃ¼nmektedir. Ã¶rneÄŸin; web development, DB manipulating/reporting, mathematical optimization, GUI development...

- 5inci jenerasyon (5GL): programcÄ±nÄ±n algoritma geliÅŸtirerek Ã§Ã¶zÃ¼m geliÅŸtirmesinin Ã¶tesinde, koÅŸullarÄ± ve kÄ±sÄ±tlarÄ± bilgisayara verdiÄŸinizde, bilgisayarÄ±n Ã§Ã¶zÃ¼mÃ¼ kendisinin bulmasÄ±na yÃ¶nelik olarak tasarlanmaktadÄ±r. BazÄ± araÅŸtÄ±rmacÄ±lar, bu tarz dillerin jenerasyon grubu altÄ±nda olamayacaÄŸÄ±nÄ± belirtmekte.

- akademik kaynaklar 4 ve 5inci jenerasyonlarÄ± Ã§ok net bir Ã§izgi ile ayÄ±rmÄ±ÅŸ durumda deÄŸil. 5inci jenerasyonun, bir jenerasyon olmamasÄ± gerektiÄŸini dÃ¼ÅŸÃ¼nenlerde var.

- Bir dil, birkaÃ§ jenerasyona birden uyabilir.

- jenerasyon yÃ¼kseldikÃ§e, daha kolay ÅŸekilde donanÄ±mdan daha baÄŸÄ±msÄ±z uygulamalar yazÄ±lmasÄ± saÄŸlanÄ±r. "high level programming language" terimi Ã¼st seviyeli diller iÃ§in kullanÄ±lÄ±r.

- en Ã¼st seviyede dahi donanÄ±mdan baÄŸÄ±msÄ±z veya donanÄ±ma baÄŸÄ±mlÄ± uygulama yazÄ±labilir. Ã§aÄŸÄ±rdÄ±ÄŸÄ±mÄ±z API (kÃ¼tÃ¼phaneler) ve/veya dilin binary/bit bazÄ±nda iÅŸlem destekleyip desteklememesi gibi Ã¶zellikler sayesinde donanÄ±ma baÄŸÄ±mlÄ± uygulamalar en Ã¼st seviyede de yazÄ±labilir.

## ğŸ“Œ bazÄ± diller

popÃ¼ler yÃ¼ksek seviyeli diller (Ã§Ä±kÄ±ÅŸ tarihleri ile - yÄ±llar draft veya stable olabilir):

- Fortran (1954)
- Lips (1956)
- COBOL (1959)

  Bu yÄ±llarda varolan programlama dillerine gÃ¶re ÅŸu avantajlarÄ± vardÄ±:
  - Ã¼st seviyeli portable dildi. diÄŸer diller gibi donanÄ±ma baÄŸlÄ±lÄ±klarÄ± aÅŸÄ±rÄ± azdÄ±.
  - okunabilir API'ler sunuyordu.
  - dosya iÅŸleme gibi iÅŸlemler iÃ§in hazÄ±r API'ler gÃ¶mÃ¼lÃ¼ydÃ¼.

  Bu sebeple banka gibi sadece business odaklÄ± logic'lerde ve pazarÄ± kaptÄ±.

- `PASCAL` (1970)
- `Prolog`, `SQL`, `C` (1972)
- `Ada` (1980)
- `C++`, `Objective-C`, `ABAP` (1983)
- `MATLAB` (1984)
- `Perl` (1987)
- `Visual Basic`, `Python` (1991)
- `Lua` (1993)
- `R` (1993)
- `Java` (1995)
- `PHP` 1995
- `Ruby` (1995)
- `JavaScript` (1995)
- `VBScript` (1996)
- `ECMAScript` (1997)
- `ActionScript` (1998)
- `C#` (2000)
- `Visual Basic .NET` (2001)

  `Visual Basic` ile bu dil farklÄ±dÄ±r. successor olarak yayÄ±mlandÄ±.

- `Scala` (2003)
- `Groovy` (2004)
- `Go` (2009)
- `CoffeeScript` (2009)
- `Rust` (2010)
- `Kotlin` (2011)
- `TypeScript` (2012)
- `Swift` (2014)

## ğŸ“Œ Yordamsal programlama dili (âŸ· Procedural programming language âŸ· prosedÃ¼rel programlama dili)

kod tekrarÄ± engellemek amaÃ§lÄ± (goto/jump gibi terimler yazmaya gerek kalmadan) programÄ±n yordamlara bÃ¶lÃ¼nmesi ile yazÄ±lmayÄ± destekleyen programlama dilleridir.

yordamsal programlama'da, programÄ±n dallandÄ±ÄŸÄ± yerlere `subroutine (âŸ· subprogram âŸ· callable unit)` adÄ± verilir. dolayÄ±sÄ± ile kullandÄ±ÄŸÄ±mÄ±z dilin diÄŸer paradigmalarÄ±na gÃ¶re "prosedure" ÅŸunlardan biri olacaktÄ±r: "function", "method".

fonksiyonel programlamadan temel farkÄ±; fonksiyonel programlamada daha Ã§ok "pure" fonksiyonlar ile Ã§alÄ±ÅŸÄ±rken, prosedÃ¼rel'de genelde pure fonksiyonlar yoktur.

## ğŸ“Œ object-oriented (âŸ· nesneye yÃ¶nelimli) vs object based (âŸ· nesne tabanlÄ±)

`JS` object-oriented deÄŸildir. nesne kullanÄ±r bu sebeple nesne tabanlÄ±dÄ±r. fakat object-oriented dillerin desteklemesi gerektiÄŸi Ã¶zellikleri destekleyecek ÅŸekilde Ã¶zenle geliÅŸtirilmez. Ã¶rneÄŸin `JS`'te inheritance ve polymorphism yoktur. son Ã§Ä±kan `JS` sÃ¼rÃ¼mlerinde sÄ±nÄ±flar gelmiÅŸtir. fakat bu seferde encapsulation yoktur.

bu iki kavram piyasada sÃ¼rekli birbiri ile karÄ±ÅŸtÄ±rÄ±lmaktadÄ±r.

object-oriented'lar ikiye ayrÄ±lÄ±r:

### ğŸ“ŒğŸ“Œ class based

sÄ±nÄ±flarÄ± kullanarak implementasyon yapan dillerdir. (Java buna bir Ã¶rnektir)

### ğŸ“ŒğŸ“Œ prototype based

bazÄ± kaynaklarda bu ÅŸekilde de isimlendirilir: prototypal, prototype-oriented, classless, instance-based programming

obje klonlayarak implementasyon yapan dillerdir. her obje tÃ¼retilen objenin prototype'Ä±nÄ± referans olarak tutar. bu yapÄ±nÄ±n en gÃ¼zel Ã¶zelliÄŸi runtime sÄ±rasÄ±nda prototype'a metot veya field eklenebilir. ve hatta prototype referansÄ±nÄ± tutan instance'lara da bu deÄŸiÅŸiklikler yansÄ±tÄ±labilir. (JS buna bir Ã¶rnektir)

## ğŸ“Œ 4 major principles of object-oriented programming

AÅŸaÄŸÄ±daki 4 madde sadece en temel principle'lerdir. Birbirlerine Ã§ok yakÄ±n principle'lerdir.

`interface` veya `abstract` sÄ±nÄ±flar ile `OOP`'nin aÅŸaÄŸÄ±daki maddelerini gerÃ§ekleyebilmemizi saÄŸlar.

not: her dilde; `Java`'daki gibi hem `interface` hem de `abstract` sÄ±nÄ±f kavramlarÄ± birden olmayabilir.

### ğŸ“ŒğŸ“Œ encapsulation (âŸ· kapsÃ¼lleme)

2 temel kavramdan oluÅŸur:

- Information hiding

  modifier'lar (public, private...) gibi keyword'ler aracÄ±lÄ±ÄŸÄ± ile bilgiyi eriÅŸime kÄ±sÄ±tlayabilmemizdir.

- Packaging

  paket(ler) veya sÄ±nÄ±f(lar) iÃ§erisinde tÃ¼m bilgilerin/metotlarÄ±n, bir unit olarak dÄ±ÅŸarÄ±ya sunulmasÄ±dÄ±r..

### ğŸ“ŒğŸ“Œ Abstraction (âŸ· soyutlama)

sÄ±nÄ±f iÃ§erisindeki detaylarÄ±n (property'lerin/metotlarÄ±n), dÄ±ÅŸarÄ±dan sÄ±nÄ±fÄ± Ã§aÄŸÄ±ranlar tarafÄ±ndan bilinmesine gerek kalmamasÄ±dÄ±r.

### ğŸ“ŒğŸ“Œ Inheritance (âŸ· kalÄ±tÄ±m)

sÄ±nÄ±flarÄ±n bir yada birden fazla yerden tÃ¼reyebilme Ã¶zelliÄŸidir.

### ğŸ“ŒğŸ“Œ Polymorphism (âŸ· polimorfizm âŸ· Ã§ok biÃ§imlilik)

tÃ¼reyen sÄ±nÄ±flar, sÃ¼per sÄ±nÄ±fÄ±n metotlarÄ±nÄ± isterse override edebilmesidir.

## ğŸ“Œ fonksiyonel programlama (âŸ· functional programming)

fonksiyonel programlama genelde;

- (Immutable) Veri YapÄ±larÄ± vardÄ±r. yani; veriyi deÄŸiÅŸtirmek yerine kopyalayarak yeni versiyonlar Ã¼retildiÄŸi,

  Not-1: Object-oriented'ta ise, bir nesnenin durumu sÃ¼rekli deÄŸiÅŸir.

  Not-2: Bunun sonucu olarak aynÄ± nesneni state'i deÄŸiÅŸmeyeceÄŸi iÃ§in, `for loop` gibi dÃ¶ngÃ¼ler yerine rekÃ¼rsif fonksiyon Ã§aÄŸÄ±rmalarÄ± daha sÄ±kÃ§a tercih edilir.

- pure fonksiyonlar ile Ã§alÄ±ÅŸÄ±ldÄ±ÄŸÄ±,

- fonksiyonlar fonksiyonlara parametre olarak geÃ§ilebildiÄŸi, return edilebildiÄŸi, bir variable'da tutulabildiÄŸi, (bu madde fonksiyonel olmanÄ±n bir zorunluÄŸu deÄŸil, ama %90 tercih edilen bir durumdur)

dillerdir.

Burada "multi-paradigm programming language" baÅŸlÄ±ÄŸÄ±nda belirtildiÄŸi gibi her dilin birden fazla Ã¶zelliÄŸi desteklediÄŸini hatÄ±rlatmak gerekli. AynÄ± zamanda yordamsal, fonksiyonel, object-oriented terimleri programlama dilinin bir Ã¶zelliÄŸi deÄŸildir. aslÄ±nda bir yazÄ±m tarzÄ±dÄ±r.

tabi ki de eÄŸer bir dilde nesne yapÄ±sÄ± hiÃ§ yoksa object-oriented tarzda uygulama yazmak mÃ¼mkÃ¼n olmayacaÄŸÄ± iÃ§in bu terimler sanki dilin bir Ã¶zelliÄŸiymiÅŸ gibi anlatÄ±lÄ±yor. oysa deÄŸil.

## ğŸ“Œ Olaya dayalÄ± programlama (âŸ· olay gÃ¼dÃ¼mlÃ¼ programlama âŸ· event-driven programming)

GUI, donanÄ±m sinyalleri gibi olaylar sonrasÄ± aksiyon alan programlama dilleridir. aslÄ±nda tÃ¼m programlama dilleri kÃ¼tÃ¼phaneleri desteklediÄŸi sÃ¼rece event bazlÄ± olabilir. fakat genelde aÄŸÄ±rlÄ±klÄ± olarak event'lere dayalÄ± programlar iÃ§in bu terim kullanÄ±lÄ±r. Ã¶rneÄŸin JS. sadece son kullanÄ±cÄ± sayfada bir yere tÄ±kladÄ±ÄŸÄ±nda yada sayfa yÃ¼klediÄŸinde bir aksiyon alÄ±nÄ±r. onun dÄ±ÅŸÄ±ndaki aksiyonlar nadirdir. zaman tetiklemeleri mevcuttur. belirli zamanda event tetiklenir. timeout metotlarÄ± gibi...

Ã¶rneÄŸin komut satÄ±rÄ± ile iÅŸlem yapan script'ler event bazlÄ± deÄŸildir.

## ğŸ“Œ declarative programming

declaration TÃ¼rkÃ§e kelime anlamÄ±: beyan etmek, bildirmek

declarative diller iÅŸin nasÄ±l yapÄ±ldÄ±ÄŸÄ±na karÄ±ÅŸmaz. sadece ne yapÄ±lmasÄ± istendiÄŸini belirtir. Ã¶rnek: SQL, CSS, HTML, Java'daki annotation'lar...

## ğŸ“Œ imperative programming

imperative TÃ¼rkÃ§e kelime anlamÄ±: zorunlu, mecbur

declarative'in tersidir. nasÄ±l olacaÄŸÄ±na tam olarak karÄ±ÅŸÄ±r ve sonuÃ§ta ne istediÄŸi dilin kendisini ilgilendirmez.
