# SECURITY

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII

## ğŸ“Œ Centralized Networks

It use __centralized servers__.

Systems like Google, Facebook, Wikipedia... It has only one authority.

## ğŸ“Œ Federated Networks

It use __decentralized servers__.

Federated messengers use multiple and independent centralized servers that are able to talk to each other.

Example:

- Email system (Gmail, Hotmail are independent but can communicate with each others)
- Matrix protocol ("Element" application use this protocol. You can find many independent matrix servers.)

## ğŸ“Œ Peer-to-peer networks

It use no servers. It is distributed network.

Examples:

- `Briar` application (it send messages directly using other client's `IP` address)
- `Bittorrent` protocol.
- `Bitcoin` and many other `cryptocurrency` (But not all of them are `Peer-to-peer`).

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ threat model (âŸ· tehdit modeli)

A threat model is a list of the most probable threats for a specific issue/topic. Since there is no way securing everything we should focus/prioritize the threads.

Example threat models:

- A threat model of journalist might be a foreign government. He has to protect himself against foreign government.
- A company's manager's threat model might be (protecting themselves against) a hacker.
- The average citizen's threat model might be (hiding their data from) large tech corporations.

The security precautions depends on the threat model. Examples for an average citizen who want to hide his data can be:

- If he use MS Windows, it's better for him to do not use a third party antivirus software. Microsoft has already a built-in defender and firewall.
- On iOS the web browsers should use Safari's web engine. This is a rule of Apple company. So in this case, for an iOS user it is better to use Safari for web browsing.
- He should not prefer 3rd party DNS providers, if his ISP has encrypted DNS.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ zero-day (âŸ· sÄ±fÄ±r-gÃ¼n âŸ· 0-gÃ¼n âŸ· sÄ±fÄ±r-saat)

zero-day is the software vulnerability which is not known yet by vendors or it's publicly not known.

The "zero-day" term means the vulnerability itself. but in some articles authors use "zero-day vulnerability" term.

n-day (example: 1-day, 2-day) means the number of the days since the first disclosure of the vulnerability.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ impersonation

TÃ¼rkÃ§e kelime anlamÄ±: kimliÄŸe bÃ¼rÃ¼nme

impersonate --> taklit etme

bir user ile baÅŸka bir user'Ä±n ÅŸifresini bilmeden onun yerine giriÅŸ yapmak isteyebilir. bu genelde yÃ¶neticiler tarafÄ±ndan yapÄ±lmaktadÄ±r. bu iÅŸleme impersonation denir.

Fakat yazÄ±lÄ±mÄ±n arka planda impersonation'dan haberi olup olmayacaÄŸÄ± standartlarda esnek bÄ±rakÄ±lmÄ±ÅŸtÄ±r. kaynak: RFC 8693 title: "1.1.  Delegation vs. Impersonation Semantics". Åu ÅŸekilde belirtilmiÅŸtir: "It is true that some members of the identity system might have awareness that impersonation is going on, but it is not a requirement.".

## ğŸ“Œ delegation

impersonation'dan farklÄ±dÄ±r. delegation'da; A user'Ä±, B user'Ä±nÄ± delegate ediyor ise, "merhaba $userName" basan bir sayfada "merhaba A" gÃ¶recektir. Yani, A kendi kimliÄŸini taÅŸÄ±maya devam etmektedir. A user'Ä±, B'nin rollerini (Ã¶nceden delege edilen (konfigÃ¼re edilen) rollerini) taÅŸÄ±maktadÄ±r (tÃ¼mÃ¼nÃ¼ taÅŸÄ±mak zorunda deÄŸil).

## ğŸ“Œ keycloak ile impersonation

keycloak token impersonation ile Oauth 2.0'a ek uzantÄ± olan "OAuth 2.0 Token Exchange" Ã¶zelliÄŸini kullanmaktadÄ±r. kaynak: RFC 8693. Fakat sÃ¼reÃ§ tamamen aynÄ± deÄŸildir ve production-ready deÄŸildir (2021 Mart).

- Production-ready destek olmadÄ±ÄŸÄ± iÃ§in keycloak'u ÅŸu ÅŸekilde baÅŸlatmak gerekiyor:

```sh
/keycloak-12.0.4/bin/standalone.sh -Dkeycloak.profile.feature.token_exchange=enabled -Dkeycloak.profile.admin_fine_grained_authz=enabled
```

- impersonation yapacak olan user'a, "realm-management" altÄ±ndaki "impersonator" rol'Ã¼ atanmalÄ±dÄ±r.

- User normal login sÃ¼recini tamamlar ve kendi access_token'Ä±nÄ± alÄ±r.

- keycloak'a ÅŸu istek atÄ±lÄ±r:

```yaml
POST http://localhost:8080/auth/realms/realm1/protocol/openid-connect/token

grant_type: urn:ietf:params:oauth:grant-type:token-exchange
client_id: $client-id
requested_subject: 1ab7cfd4-5401-4985-b264-145c25aa6c19 (taklit edilecek user'Ä±n Keycloack-ID'si)
subject_token: $current(impersonator)-access-token
client_secret: $client-secret
```

Response olarak bize access ve refresh token dÃ¶necektir. Bu dÃ¶nen JWT'leri decode edersek iÃ§erisinde taklit edilen user'Ä±n bilgilerinin (role, isim...) olduÄŸunu gÃ¶receÄŸiz.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ vault

`Hashicorp` firmasÄ± tarafÄ±ndan geliÅŸtirilen aÃ§Ä±k kaynaklÄ± key management yazÄ±lÄ±mÄ±.

## ğŸ“Œ config file

`HCL` (`HashiCorp Configuration Language` kÄ±saltmasÄ±dÄ±r) formatÄ±ndadÄ±r. `HCL`, `JSON` ve `YAML`'ye alternatif olarak geliÅŸtirilmiÅŸtir. Ã¶rnek syntax:

```hcl
service {
    key = "value"
}

service2 {
    key2 = "value2"
}

// comment-1

## comment-2

/* multi-line
   comment */

root1 "child1" {
    prop1 = "value1"
}
// equivalent to YAML:
// root1.child1.prop1: value1
```

## ğŸ“Œ initialization

`vault` sunucusu baÅŸladÄ±ÄŸÄ±nda sadece 1 kere init etmek gerekli. init output'u olarak ÅŸunlar basÄ±lÄ±yor:

- 5 adet unseal-key'lerÄ±

  unseal-key'lerden en az 3 tanesi ile vault ancak unseal edilebiliyor. Unsealing sÃ¼reci her sunucu restart'Ä±nda gerektiÄŸi iÃ§in bu key'lere ihtiyacÄ±mÄ±z olacak.

- 1 adet root token

  bu token ile client her iÅŸlemi yapabiliyor.

## ğŸ“Œ secret engine

vault'ta her ÅŸeyi gruplamak amaÃ§lÄ± her "secret" belli 1 adet "secret engine" altÄ±nda olmalÄ±dÄ±r. bu ÅŸekilde bir secret engine'i komple disable edebiliriz yada enable edebiliriz.

## ğŸ“Œ authentication

client'Ä±n vault'tan data Ã§ekmesi veya manipÃ¼lasyon yapabilmesi iÃ§in her uygulamada olduÄŸu gibi Ã¶nce login olmalÄ±dÄ±r. "token" ile authentication'da buna bir Ã¶rnektir.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ subresource integrity

web tarayÄ±cÄ±larÄ± indirdikleri dosyanÄ±n hash'ine bakarak validasyon yapar. eÄŸer valid deÄŸilse o dosyayÄ± HTML'e import etmez.

```html
<script src="https://example.com/example-framework.js"
        integrity="sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC"
```

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Trust on first use (âŸ· TOFU âŸ· trust upon first use âŸ· TUFU)

2 makinenin haberleÅŸmesinde ilk aÅŸamada birbirlerine bir identifier Ã¼zerinden gÃ¼venmeleri tekniÄŸidir. TOFU kullanan birkaÃ§ Ã¶rnek Ã¼zerinden gidelim:

- `SSH`

  SSH client sunucuya baÄŸlandÄ±ÄŸÄ±nda, eÄŸer bu sunucuya giderken (eÄŸer bu sunucu iÃ§in daha Ã¶nce son kullanÄ±cÄ±dan onay alÄ±nmamÄ±ÅŸ ise), son kullanÄ±cÄ±ya sunucunun identifier'ini gÃ¶sterir. eÄŸer son kullanÄ±cÄ± onaylar ise artÄ±k bu bilgiyi shh client $HOME dizinine kaydeder ve bir daha son kullanÄ±cÄ±ya sormaz.

- `HPKP`

  browser sunucuya eriÅŸip sertifikasÄ±nÄ± aldÄ±ÄŸÄ±nda onu valide ederse doÄŸru olarak kabul eder ve bu bilgiyi DB'ye kaydeder. Ä°lerideki zamanlarda tekrar aynÄ± sunucuya gidildiÄŸinde, DB'de bulunan key'lere gÃ¶re sunucuyu valide eder.

- `Signal` messenger

  `Signal` karÅŸÄ± tarafÄ±n identifier'ini son kullanÄ±cÄ±ya sadece gÃ¶sterir ve karÅŸÄ± taraf ile iletiÅŸimi son kullanÄ±cÄ±nÄ±n onayÄ± olmadan baÅŸlatÄ±r. yani `TOFU`'yu direk(onaysÄ±z) uygular. Son kullanÄ±cÄ± eÄŸer isterse identifier'Ä± karÅŸÄ±daki kiÅŸiden manuel barcode aracÄ±lÄ±ÄŸÄ± ile kontrol edebilir.

  EÄŸer karÅŸÄ±dakinin identifier'i deÄŸiÅŸirse, signal bizi uyarÄ±r. fakat yine iletiÅŸime devam eder.

  eÄŸer biz karÅŸÄ± tarafÄ±n identifier'ini signal uygulamasÄ± iÃ§erisinden "verified" olarak iÅŸaretlersek ve karÅŸÄ±dakinin identifier'i deÄŸiÅŸirse, signal sadece uyarmakla kalmaz aynÄ± zamanda iletiÅŸimi block'lar.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Crypto-shredding

shredding kelime anlamÄ±: parÃ§alama

ÅŸifrelenmiÅŸ data'larÄ± kullanÄ±lamaz hale getirmek iÃ§in tÃ¼m ÅŸifrelenmiÅŸ data'larÄ± tek tek override etmek veya silmek yerine, sadece decryption key'i silme Ã§Ã¶zÃ¼mÃ¼dÃ¼r.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ 3 state of data in computer science

- __Data at rest__

  data'nÄ±n, kalÄ±cÄ± storage'de durma durumudur.

- __Data in transit (âŸ· data in motion âŸ· data in flight)__

  data'nÄ±n, network Ã¼zerinde taÅŸÄ±ndÄ±ÄŸÄ± durumlardÄ±r. IPC gibi durumlar bu gruba dahil deÄŸildir.

- __Data in use__

  data'nÄ±n, RAM, "CPU cache" gibi kalÄ±cÄ± olmayan bellekte olma durumudur.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ confused deputy problem

deputy kelime anlamÄ±: vekil

client olarak; bir servise bir istek yaptÄ±k, bu servis iÅŸlemi yapabilmek iÃ§in diÄŸer servislere de istek yapÄ±yor. dolayÄ±sÄ± ile diÄŸer servisler ilgili isteÄŸin nereden geldiÄŸini bilebilmeli. gÃ¼venliÄŸi buna gÃ¶re implemente etmeliyiz. Ã§Ã¼nkÃ¼ diÄŸer servislere dÄ±ÅŸarÄ±dan da istek gelebiliyor. bu istek internal'dan mÄ± geliyor yoksa client'tan mÄ±, her servis bunu ayÄ±rt edebilmeli. AynÄ± zamanda client yaptÄ±ÄŸÄ± bu istek ile diÄŸer servislere istek tetikleyebilmiÅŸ oluyor. burada farklÄ± zafiyetler sÃ¶z konusu olabiliyor. bu durum "__confused deputy__" problem olarak adlandÄ±rÄ±lÄ±yor. Ã‡Ã¼nkÃ¼ her aracÄ± servis client adÄ±na istek atmÄ±ÅŸ oluyor. bu aracÄ± servisler, bu problem kapsamÄ±nda vekil olarak adlandÄ±rÄ±lÄ±yor.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ secret zero problem (âŸ· secret-zero problem)

bir data'yÄ± ÅŸifrelemek iÃ§in ÅŸifre kullanÄ±rsÄ±nÄ±z. bu ÅŸifreyi de ÅŸifrelemek iÃ§in bir ÅŸifre kullanÄ±rsÄ±nÄ±z. bu ÅŸekilde 100 adÄ±m dahi yapabiliriz. fakat her zaman mutlaka bir ÅŸifreyi koruma gereÄŸi duyacaÄŸÄ±z. bu ÅŸifre'ye "secret zero" denir. "secret-zero problemi" ise; bu ÅŸifreyi nasÄ±l koruyacaÄŸÄ±mÄ±zdÄ±r.

"secret zero" problemine Ã§Ã¶zÃ¼m bulmak teorikte imkansÄ±z. Ã§Ã¼nkÃ¼ hack'lenecek her zaman son bir sistem/ÅŸifre olmalÄ±dÄ±r. fakat bazÄ± sistemler son katmanÄ± parÃ§alara bÃ¶lerek "secret zero" problemini kÄ±smen de olsa Ã§Ã¶zmektedirler. Ã¶rneÄŸin, bir "master key", "secret zero" olsun. bu master key'i, 2 ye bÃ¶lersek, o zaman bu master key ile iÅŸlem yapmak istediÄŸimizde bu 2 kiÅŸiye de ulaÅŸmamÄ±z gerekecek. yani; "secret zero" tek bir yere baÄŸÄ±mlÄ± deÄŸil. her kiÅŸide multi-factor authentication sistemleri ile korunur. bu ÅŸekilde secret-zero'yu korumak iÃ§in farklÄ± baÄŸÄ±mlÄ±lÄ±klarda eklenmiÅŸ olur.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ SQL injection (âŸ· SQLi)

- SQL injection'dan kaÃ§mak iÃ§in ORM framework sÃ¼rÃ¼mÃ¼mÃ¼zÃ¼n gÃ¼ncel olmasÄ±na dikkat etmeliyiz. Ã§Ã¼nkÃ¼ ORM'nin aÅŸaÄŸÄ±da Ã¶rneklendirilen bind iÅŸleminde kontroller gerÃ§ekleÅŸtiriyor.

- DÄ±ÅŸarÄ±dan alÄ±nan parametreleri bind ederek tanÄ±mlamalÄ±yÄ±z:

```java
Query query = createQuery("from LoginUsers where userName=:userName");

query.setParameter("username", userName); //ORM burada userName'in tipini biliyor ve kontrolleri kendisi yapÄ±yor.
```

Bind etmeyi sadece SQL komutlarÄ± iÃ§in deÄŸil, JPQL iÃ§in dahi yapmalÄ±yÄ±z. SQL ile JPQL farksÄ±zdÄ±r. JPQL; ancak bind edilirse gÃ¼venliÄŸi saÄŸlar.

- Dinamik query yapÄ±lacak ise Criteria API'den faydalanÄ±lmalÄ±

## ğŸ“Œ tipleri

### ğŸ“ŒğŸ“Œ In-band SQLi (âŸ· Classic SQLi)

#### ğŸ“ŒğŸ“ŒğŸ“Œ Error-based SQLi

Exception detaylarÄ± uygulamadan dÃ¶nÃ¼yor ise, bunlardan yola Ã§Ä±karak sunucudan bilgi toplanÄ±r.

#### ğŸ“ŒğŸ“ŒğŸ“Œ Union-based SQLi

```sql
select * from X where ' $VAR '
```

gibi SQL'lerde VAR input'unu deÄŸiÅŸtirerek sunucudan bilgi toplanÄ±rÄ±z. VAR yerine bir ÅŸey eklememiz ancak ve ancak UNION sorgularÄ± ile mÃ¼mkÃ¼ndÃ¼r. bu sebeple bu ataklara Union-based denir.

### ğŸ“ŒğŸ“Œ Inferential SQLi (âŸ· Blind SQLi)

#### ğŸ“ŒğŸ“ŒğŸ“Œ Boolean-based (âŸ· content-based) Blind SQLi

Sunucuda bu ÅŸekilde bir HTTP Controller olsun:

```java

@HTTP_GET
isExist(String input){

    boolean exist = runSQL("SOME SQL" + input);

    if(exist){
      return "true";
    } else {
      return "false";
    }
}
```

Bu controller'dan bilgi almak iÃ§in ÅŸÃ¶yle bir yÃ¶ntem geliÅŸtirilebiliriz:

input'taki SQL'imiz Ã¶nce tÃ¼m tablolarÄ± Ã§eken SQL'i Ã§alÄ±ÅŸtÄ±racak. sonra aynÄ± SQL'de, bu tablo listesindeki ilk elemanÄ±n (ilk tablo adÄ±nÄ±n) ilk karakteri A mÄ± diye bakÄ±lacak. eÄŸer A ise "boolean exist = true" olacak ÅŸekilde dÃ¶nÃ¼ÅŸ yapÄ±lmalÄ±. eÄŸer true olursa demek ki ilk karakter A.

AynÄ± iÅŸlemi ilk tablonun ikinci elemanÄ± iÃ§inde yapmalÄ±yÄ±z ve tÃ¼m alfabe ve Ã¶zel karakterler iÃ§in yapmalÄ±yÄ±z. Her tablo adÄ± 100 karakter olsa, 100 tablo olsa, 50 karakter kombinasyonu olsa, 100\*100*50 adet HTTP isteÄŸinde tÃ¼m tablo listesini almÄ±ÅŸ oluruz.

Bu iÅŸlemi daha hÄ±zlandÄ±rmak iÃ§in farklÄ± yÃ¶ntemler mevcut. Ã–rneÄŸin; Tablo isminin ilk karakterinin ASCII karÅŸÄ±lÄ±ÄŸÄ± alÄ±nÄ±r. Ã–rneÄŸin bu deÄŸer 50 olsun. Biz SQL sorgumuzda bu deÄŸer 50'den kÃ¼Ã§Ã¼kse "boolean exist = true" dÃ¶necek ÅŸekilde ayarlarÄ±z. EÄŸer true dÃ¶nerse; ASCII 50'nin Ã¼zerindeki hiÃ§bir karakter iÃ§in HTTP denemesi yapmamÄ±za gerek kalmayacak. Bu tarz trick'lerle deneme sayÄ±mÄ±zÄ± Ã§ok azaltabiliriz.

#### ğŸ“ŒğŸ“ŒğŸ“Œ Time-based Blind SQLi

controller'Ä±mÄ±z boolean dahi dÃ¶nmÃ¼yor olsun:

```java
@HTTP_GET
anyMethod(String input){

    runSQL("SOME SQL" + input);
}
```

Buradan bilgi alabilmek iÃ§in Boolean-based ile aynÄ± SQL'leri Ã§alÄ±ÅŸtÄ±racaÄŸÄ±z. Fakat dÃ¶nÃ¼ÅŸÃ¼mÃ¼zde true false alamadÄ±ÄŸÄ±mÄ±zdan, dÃ¶nÃ¼ÅŸ deÄŸerimiz yerine zaman aralÄ±ÄŸÄ±ndan faydalanacaÄŸÄ±z. SQL'lerimiz true durumunda sleep(7) gibi bir SQL fonksiyonu Ã§alÄ±ÅŸtÄ±racak. eÄŸer 7 saniye iÃ§inde cevap gelmezse, o SQL sonucunu true olarak varsayacaÄŸÄ±z.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Insecure Direct Object References (âŸ· IDOR)

Ã¶rneÄŸin DB satÄ±rÄ±nÄ±n primary-ID'leri API'de CRUD amaÃ§lÄ± kullanÄ±lÄ±yorsa, bunlar IDOR'dur.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ PIN (âŸ· Personal Identification Number)

geÃ§ici olarak kullanÄ±lan ÅŸifredir.

## ğŸ“Œ PIN pad (âŸ· PIN entry device âŸ· PED)

PIN girilen cihazlara verilen genel isimdir.

## ğŸ“Œ Multi-factor authentication (âŸ· MFA)

factor TÃ¼rkÃ§e kelime anlamÄ±: faktÃ¶r, etken

birden fazla faktÃ¶rden onay alÄ±nmasÄ±. faktÃ¶rler:

- Bilgi (Knowledge)

  Åifre, PIN, gÃ¼venlik sorusu

- Sahiplik (Possession)

  Telefon, donanÄ±m anahtarÄ±

- Biyometri (Inherence)

  Parmak izi, yÃ¼z, retina

MFA Ã¶rnekleri:

- SMS codes
- email codes
- app push notifications
- Time-based One-time Passwords (TOTP)
- Yubico OTP
- FIDO2/U2F

## ğŸ“Œ Two-factor authentication (âŸ· 2FA)

MFA'nÄ±n 2 adÄ±mlÄ± olanÄ±dÄ±r.

## ğŸ“Œ Two-step verification (âŸ· two-step authentication)

MFA deÄŸildir.

Ã¶rneÄŸin CAPTCHA + ÅŸifre kullanmak Two-step verification'dÄ±r. Ama 2FA deÄŸildir.

## ğŸ“Œ TOTP (âŸ· Time-Based One-Time Password)

Bir OTP Ã§eÅŸididir. Offline olarak OTP Ã¼retir. Bu OTP sadece belirli bir sÃ¼re geÃ§erlidir. Bu sebeple Time based'dir.

## ğŸ“Œ Google authenticator

TOTP kullanÄ±mÄ±nÄ± saÄŸlayan bir GUI uygulamasÄ±dÄ±r. KullanÄ±cÄ± parametre olarak OTP'nin yenileneceÄŸi dÃ¶ngÃ¼ sÃ¼resi (varsayÄ±lan 30 saniye) ve secret-key'i Google'den alÄ±r. Bu parametreler ile 30 saniyede bir yeni bir OTP Ã¼retir. Bu OTP'nin algoritmasÄ± bellidir. Bu sebeple offline olarak OTP Ã¼retilebilir.

"Google authenticator" aÃ§Ä±k kaynaklÄ± bir algoritmaya dayanÄ±r. bu sebeple alternatifi birÃ§ok client ve programlama dili API'si mevcuttur.

## ğŸ“Œ otp hakkÄ±nda

otp sÃ¼resi algoritma gÃ¶re deÄŸil, kullanÄ±ldÄ±ÄŸÄ± hizmetin kendisine gÃ¶re deÄŸiÅŸir. yani; Google'Ä±n kullandÄ±ÄŸÄ± algoritma 30 saniyeliktir. fakat aynÄ± algoritmayÄ± 40 saniye olacak ÅŸekilde de ayarlayabiliriz.

otp ÅŸifresi T zamanÄ±nda Ã¼retilmiÅŸ olsun. artÄ±k bu T zamanÄ±nda Ã¼retilen otp Google iÃ§in 30 saniye sÃ¼resinde kabul gÃ¶recektir. T+1 zamanÄ±nda aynÄ± secret key ile bir OTP Ã¼retelim. Bu password'de artÄ±k 30 saniye geÃ§erli olacaktÄ±r. dolayÄ±sÄ± ile T+1 de oluÅŸturduÄŸumuz key daha farklÄ±dÄ±r. Fakat T+2 anÄ±nda her 2 key'imizde geÃ§erlidir.

Ã–rneÄŸin; <https://github.com/bilelmoussaoui/Authenticator> uygulamasÄ± ile masaÃ¼stÃ¼nde aynÄ± secret key ile iki ÅŸifre oluÅŸturduÄŸumuzda, iki ÅŸifre farklÄ± zamanlarda oluÅŸturulacaÄŸÄ± iÃ§in farklÄ± key gÃ¶stereceklerdir. her 30 saniyede bir yeni key oluÅŸturacaklar ve her ikisinin dÃ¶ngÃ¼sÃ¼nÃ¼n sona erdiÄŸi an farklÄ± olduÄŸundan hep farklÄ± key Ã¼retecekler.

BazÄ± servisler her 2 anahtarÄ± da kabul etmektedir. Fakat Google bunu kabul etmiyor. "Google authenticator" uygulamasÄ± bu durumu ÅŸu ÅŸekilde Ã§Ã¶zÃ¼yor. "Google authenticator" kendi iÃ§inde belli zaman aralÄ±klarÄ± belirlemiÅŸ. Her 30 saniye bir zaman aralÄ±ÄŸÄ± iÃ§inde, yani 00:00:00 - 00:00:30 ilk zaman aralÄ±ÄŸÄ±.  00:00:30 - 00:00:60 ikinci zaman aralÄ±ÄŸÄ±. EÄŸer 00:00:35 anÄ±nda bir key Ã¼retirsek; bizi ikinci zaman aralÄ±ÄŸÄ±na otomatik alÄ±yor ve 00:00:30 anÄ±nda ÅŸifreyi Ã¼retmiÅŸiz gibi varsayÄ±yor ve buna gÃ¶re hesaplamalarÄ± yapÄ±yor. DolayÄ±sÄ± ile her 30 saniye iÃ§in en fazla 1 farklÄ± key Ã¼retebiliyoruz. Bu tamamen "Google authenticator" yazÄ±lÄ±mÄ±nÄ±n Ã¶nyÃ¼zde uyguladÄ±ÄŸÄ± bir mantÄ±ktÄ±r. anahtar Ã¼retim algoritmasÄ± ile baÄŸlantÄ±lÄ± bir durum deÄŸildir.

AynÄ± durum <https://github.com/bilelmoussaoui/Authenticator> iÃ§in geÃ§erli deÄŸildir.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Post-quantum cryptography (âŸ· quantum-proof âŸ· quantum-safe âŸ· quantum-resistant)

`Kuantum` hesaplamalarÄ± fizik kurallarÄ± gereÄŸi her tÃ¼rlÃ¼ hesaplamayÄ± verimli ÅŸekilde yapamamaktadÄ±r. Bu sebeple `kuantum` teknolojisinin hÄ±zlÄ± hesaplamaya tabi tutamayacaÄŸÄ± algoritmalar ortaya atÄ±lmÄ±ÅŸtÄ±r.

2019 yÄ±lÄ± itibari ile Ã§oÄŸu asimetrik ÅŸifreleme (`private key` ve `public key` yapÄ±sÄ±na dayanan ÅŸifreleme) algoritmalarÄ± `kuantum` bilgisayarlarÄ±na karÅŸÄ± direnÃ§siz. `Simetrik` algoritmalar ise direnÃ§li. Fakat simetrik algoritmalar'Ä±n anahtarlarÄ± yarÄ±ya dÃ¼ÅŸÃ¼rÃ¼lmÃ¼ÅŸ kadar daha hÄ±zlÄ± Ã§Ã¶zÃ¼lebiliyor. Ã¶rneÄŸin 512'lik bir anahtara sahip bir ÅŸifreleme algoritmasÄ±, eÄŸer `kuantum` bilgisayarÄ± ile kÄ±rÄ±lÄ±rsa, quantum olmayan bir bilgisayarda 256'lÄ±kmÄ±ÅŸ hÄ±zÄ±nda kÄ±rÄ±labiliyor.

2019 yÄ±lÄ± itibari ile Ã¶zgÃ¼r lisanslÄ± ve ticari anlamda tÃ¼mÃ¼yle kullanÄ±labilecek quantum resistant algoritmasÄ± yoktur. Olanlar ya lisanslÄ±, yada key'leri bÃ¼yÃ¼k olmasÄ± gibi Ã¶nemli dezavantajlarÄ± mevcut.

## ğŸ“Œ quantum algorithms

kuantum bilgisayarlarÄ±n verimli Ã§Ã¶zdÃ¼ÄŸÃ¼ algoritmalardÄ±r.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ HTTP Public Key Pinning (âŸ· HPKP)

`Ssl` iÅŸlemlerine ek gÃ¼venlik yapmak iÃ§in kullanÄ±lan bir yÃ¶ntemdir. Sunucu cevaplarÄ±nÄ±n header'Ä±na ÅŸunu ekler:

```text
Public-Key-Pins:
         pin-sha256="cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=";

         pin-sha256="M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=";

         max-age=5184000
```

TarayÄ±cÄ± bu deÄŸerleri tÃ¼m yaÅŸamÄ± boyunca (en fazla `max-age` e gÃ¶re) saklar. `Pin-SHA` deÄŸeri sunucunun `public key` `SHA`'dÄ±r. EÄŸer ileride bir hacker sunucunun dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ `public key`'i deÄŸiÅŸtirirse; tarayÄ±cÄ± (sunucuya hiÃ§ gitmeden) eski `SHA`'larÄ± da kontrol edeceÄŸi iÃ§in bir sorun olduÄŸunu anlayacak ve kullanÄ±cÄ±yÄ± uyaracaktÄ±r.

2 tane pin olmasÄ±nÄ±n sebebi max-age sÃ¼resince sunucunun gerÃ§ekten de `public key`'ini deÄŸiÅŸtirmesi durumunda kullanÄ±lacak backup'tÄ±r. Sunucu dilediÄŸi kadar `pin-SHA` yollayabilir.

Bir siteye bir tarayÄ±cÄ±dan ilk defa gidiliyorsa, bu gÃ¼venlik Ã¶nlemi bir iÅŸe yaramaz.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ browser fingerprint

bu bilgilerin kombinasyonlarÄ± ile yine browser'Ä±n tekilliÄŸini tespit edebilmektedirler.

- browser'Ä±n destekleyip desteklemediÄŸi her feature
- hangi fontlarÄ±n yÃ¼klÃ¼ olduÄŸu listesi
- user agent
- OS tipi
- CPU tipi
- timezone
- screen resolution
- dil

gibi daha bir Ã§ok parametre ile tarayÄ±cÄ±nÄ±n tekilliÄŸi ortaya koyulabilmektedir.

hatta bazÄ± Ã¶zellikler tek baÅŸlarÄ±na %100 unique'liÄŸi saÄŸlayabilmekte, bazÄ± Ã¶zellikler yine tek baÅŸlarÄ±na %99 oranÄ±nda unique'liÄŸi saÄŸlayabilmektedirler.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Biyometri (âŸ· biometry)

yaÅŸayan organizmalarÄ±n Ã¶lÃ§Ã¼mlerine verilen genel isimdir. tÃ¼m niteliklerin sayÄ±sal ortama aktarÄ±lmÄ±ÅŸ halidir.

## ğŸ“Œ biyometrik kimlik doÄŸrulama yÃ¶ntemleri (âŸ· biometric verification methods)

- parmak izi (âŸ· fingerprint) (parmaklara gÃ¶zle detaylÄ± bakÄ±ldÄ±ÄŸÄ±nda bu ÅŸekiller gÃ¶rÃ¼lebilir)
- yÃ¼z tanÄ±ma (âŸ· face recognition)
- damar izi (âŸ· vein scar)
  - parmak damar izi (âŸ· finger vein print)
  - avuÃ§ iÃ§i damar izi (âŸ· palm vein print)
- gÃ¶z tarama
  - retina taramasÄ± (âŸ· retinal scan)
  - iris tanÄ±ma (âŸ· iris recognition)
- ses tanÄ±ma (âŸ· voice recognition)
- (el yazÄ±lÄ±) imza

yukarÄ±daki biyometrik bilgiler geniÅŸleyebilir/bÃ¼yÃ¼yebilir fakat ÅŸekilleri deÄŸiÅŸmez. bu sebeple Ã¶mÃ¼r boyu aynÄ± kalÄ±rlar.

engelli kiÅŸiler, bazÄ± biyometrik bilgileri veremediÄŸi unutulmamalÄ±dÄ±r.

her veri, teorik olarak replika edilebilir. fakat baÅŸka baÅŸlÄ±kta anlatÄ±ldÄ±ÄŸÄ± gibi; authentication amaÃ§lÄ± yukarÄ±daki her biyometrik veri kullanÄ±labilir. Ã§Ã¼nkÃ¼ authentication yapÄ±lÄ±rken, %100 aynÄ± olan replica'lar kabul edilememektedir.

hatalar genelde ÅŸunlardan kaynaklanmaktadÄ±r:

- yazÄ±lÄ±msal/algoritmik hatalar
- kontrol edilen biyometrik cihazlarÄ±n ucuz olmasÄ±ndan kaynaklÄ± hassas data toplanamamasÄ± (Ã¶rneÄŸin; kameranÄ±n kalitesiz olmasÄ± durumunda, gÃ¶rÃ¼ntÃ¼ detaylÄ± pixel'lere sahip deÄŸildir. bu da hatalara sebebiyet verebilir. Ã§Ã¼nkÃ¼ hassas Ã¶lÃ§Ã¼mler yapÄ±lamaz.)

TÃ¼m biyometrik sistemler aÅŸaÄŸÄ±da aÃ§Ä±klanmÄ±ÅŸ olan beÅŸ Ã¶zelliÄŸe sahip olmalÄ±dÄ±r:

- Evrensellik: TÃ¼m bireyler biyometrik Ã¶zelliklere sahip olmalÄ±dÄ±r.
- EÅŸsiz olma: Biyometrik karakteristiÄŸin her insanda farklÄ± bir ÅŸekilde yer almasÄ±.
- SÃ¼reklilik: KarakteristiÄŸin zamanla deÄŸiÅŸmemesi.
- Elde edilebilirlik: Biyometrik Ã¶zelliklerin bazÄ± pratik cihazlarla Ã¶lÃ§Ã¼lebilir olmasÄ±.
- Kabul edilebilirlik: Bireylerin biyometriÄŸin Ã¶lÃ§Ã¼m ve toplanmasÄ±nda itirazlarÄ± olmamalÄ±

| Biyometrik Karakteristik | Evrensellik | EÅŸsizlik | SÃ¼reklilik | Elde Edilebilirlik | Performans | kabul Edilebilirlik | YaygÄ±nlÄ±k |
|--------------------------|-------------|----------|------------|--------------------|------------|---------------------|-----------|
| DNA                      | Y           | Y        | Y          | D                  | Y          | D                   | D         |
| Kulak                    | O           | O        | Y          | O                  | O          | Y                   | O         |
| YÃ¼z                      | Y           | D        | O          | Y                  | D          | Y                   | Y         |
| YÃ¼z TermogramÄ±           | Y           | Y        | D          | Y                  | O          | Y                   | D         |
| Parmak Ä°zi               | O           | Y        | Y          | O                  | Y          | O                   | O         |
| El Geometrisi            | O           | O        | O          | Y                  | O          | O                   | O         |
| Ä°ris                     | Y           | Y        | Y          | O                  | Y          | D                   | D         |
| Retina                   | Y           | Y        | O          | D                  | Y          | D                   | D         |
| Ä°mza                     | D           | D        | D          | Y                  | D          | Y                   | Y         |
| Ses                      | O           | D        | D          | O                  | D          | Y                   | Y         |

Y:YÃ¼ksek O:Orta D:DÃ¼ÅŸÃ¼k

## ğŸ“Œ parmak izi (âŸ· fingerprint)

parmak izi en sÄ±k kullanÄ±lan, en basit ve ucuz yÃ¶ntemlerle tespit edilen ve karÅŸÄ±laÅŸtÄ±rÄ±labilen metotlardandÄ±r. bu sebeple sÄ±k kullanÄ±lÄ±r.

parmak izinin %100 benzersiz olduÄŸuna dair bir tez yoktur. fakat ÅŸu ana dek aynÄ± parmak izi olduÄŸu gÃ¶rÃ¼lmemiÅŸtir. bu sebeple herkes eÅŸsiz olarak varsayar. bazÄ± kurumlar, bu sebepten Ã¶tÃ¼rÃ¼ sadece 1 parmaÄŸÄ±n deÄŸil, garantilemek amacÄ± ile birden fazla parmak izini birden saklamaktadÄ±r. Bunun ayrÄ± bir sebebi de, kÃ¶tÃ¼ niyetli kiÅŸinin, fiziksel olarak baÅŸkasÄ±nÄ±n parmaÄŸÄ±nÄ± kullanabilme ihtimalidir. Bu durumda kÃ¶tÃ¼ niyetli kiÅŸinin birden fazla parmaÄŸÄ± ele geÃ§irmiÅŸ olmasÄ± gerekecektir.

parmak izi benzerliÄŸini kontrol etmek iÃ§in kullanÄ±lan birÃ§ok algoritma mevcut.

alÄ±nan parmak izinin ne kadar detaylÄ± alÄ±ndÄ±ÄŸÄ± da Ã¶nemlidir. Ã§ok kalitesiz alÄ±nan parmak izi kaydÄ±, yanlÄ±ÅŸ sonuÃ§lara yol aÃ§abilir.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Pentest (âŸ· penetration test)

Penetration TÃ¼rkÃ§e anlamÄ± nÃ¼fuz etmek, delmek, iÃ§ine girmektir.

sisteme sÄ±zma testleridir. bu testler ile gÃ¼venlik aÃ§Ä±klarÄ± tespit edilir.

## ğŸ“Œ Whitebox vs Blackbox vs Greybox

Pentest tipleridir. Pentest'i yapacak ekibe sistem hakkÄ±nda:

- hiÃ§bir bilgi verilmiyor ise Blackbox testidir.
- tÃ¼m bilgiler (kodlar, network) veriliyor ise Whitebox testidir.
- kÄ±smen/bazÄ± bilgileri veriliyor ise Greybox testidir.

## ğŸ“Œ Blackbox

kelime anlamÄ±: mat (parlak olmayan, Ä±ÅŸÄ±k geÃ§irmeyen).

Blackbox biliÅŸim dÃ¼nyasÄ±nda sadece input ve output'larÄ± gÃ¶zlenebilen fakat iÃ§i gÃ¶rÃ¼nmeyen her ÅŸeye denir.

## ğŸ“Œ Vulnerability Assessment (âŸ· zafiyet tarama)

direk gÃ¼venlik aÃ§Ä±ÄŸÄ± bulmaz. fakat gÃ¼venliÄŸi tetikleyici etkenleri tespit eder.

Ã¶rneÄŸin; Java sÃ¼rÃ¼mÃ¼ eski ise uyarÄ±r.

## ğŸ“Œ Alpha Testing Vs Beta Testing

JUnit integration ve sistem testleri koÅŸulduktan sonra yapÄ±lan testlerdir. buradan sonra yapÄ±lan testler "user acceptance test" olduÄŸu iÃ§in alpha ve beta da user acceptance testi olarak geÃ§er.

alpha testleri genelde bu iÅŸin uzmanÄ± kiÅŸilerin yaptÄ±ÄŸÄ± testlerdir. beta testleri ise public fakat sadece belli kiÅŸilerin test etmesi sÃ¼recidir.

## ğŸ“Œ functional requirement

- yazÄ±lÄ±m/sistem ihtiyaÃ§ analizleri iÃ§in kullanÄ±lan terimdir.
- spesifik bir fonksiyonalite/Ã¶zellik iÃ§in yazÄ±lmÄ±ÅŸ olmasÄ± gereken ihtiyaca verilen sÄ±fattÄ±r. Ã¶rnek:
  - son kullanÄ±cÄ± formu yolla tuÅŸuna ancak ÅŸifresini girdikten sonra baÅŸarabilecektir.
  - ikinci sayfadan sonra direk dÃ¶rdÃ¼ncÃ¼ sayfaya geÃ§iÅŸ mÃ¼mkÃ¼n olmalÄ±dÄ±r.

## ğŸ“Œ Non-functional requirement

bu ihtiyaÃ§lar spesifik Ã¶zellikler iÃ§in belirtilmez. genel sisteme hitap eder. Ã¶rnek:

- sistem 10.000 kiÅŸiyi destekleyecektir.
- yazÄ±lÄ±m gÃ¼ncel Linux sistemlerini destekleyecektir.

BazÄ± kaynaklarda __cross-functional requirement__ olarak geÃ§mektedir. Kaynak: "Sam Newman" "Building microservices" kitabÄ±nÄ±n 151'inci sayfasÄ±nda "cross-functional testing" baÅŸlÄ±ÄŸÄ±, 2inci paragraf.

## ğŸ“Œ Functional Testing vs Non-Functional Testing

fonksiyonel test sadece belirli bir Ã¶zelliÄŸe istinaden koÅŸulan testlerdir. oysa Non-Functional performans gibi kriterleri Ã¶lÃ§mek iÃ§in yapÄ±lan testlerdir.

## ğŸ“Œ regresyon testleri

yazÄ±lÄ±ma eklenen yeni bir Ã¶zelliÄŸin, sistemde zaten var olan diÄŸer Ã¶zellikleri etkileyip etkilemediÄŸinin testleridir. bu durumda aslÄ±nda tÃ¼m sistem baÅŸtan sona test edilmesi gerekir fakat bu yÃ¼ksek maliyet olacaktÄ±r. bu sebeple; sadece etkisi olabilecek potansiyel modÃ¼ller test edilmelidir.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ BackTrack

pentest yapabilmek iÃ§in gerekli tool'larÄ±n bir arada sunan, Linux tabanlÄ±, live CD/USB ile Ã§alÄ±ÅŸan OS'tur.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ IPSec

Internet protocol katmanÄ±nda gizlilik ve doÄŸruluk saÄŸlamaya yÃ¶nelik gÃ¼venlik standartlarÄ± grubudur.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Rootkit

sistemin admin kullanÄ±cÄ± haklarÄ±nÄ± ele geÃ§irip iÅŸlem yapmaya Ã§alÄ±ÅŸan malware'dir. genelde algÄ±lanmalarÄ± zordur, Ã§Ã¼nkÃ¼ zaten en yÃ¼ksek seviyede yetkiye sahiptirler ve bu sebeple kendilerini gizlemeleri kolaydÄ±r.

## ğŸ“Œ IP spoofing (âŸ· IP sahteciliÄŸi)

IP adresini farklÄ± gÃ¶sterip request gÃ¶nderme iÅŸlemdir. Tabi cevap bizim isteÄŸi yolladÄ±ÄŸÄ±mÄ±z makinaya deÄŸil, IP sahibi makinaya gidecektir. Fakat IP sahteciliÄŸinde dÃ¶nÃ¼ÅŸ cevabÄ± Ã¶nemsenmez. YapÄ±lmasÄ±nÄ±n amaÃ§larÄ± farklÄ±dÄ±r. Ã–rneÄŸin; sunucunun bant kaynaklarÄ±nÄ± tÃ¼ketmek.

## ğŸ“Œ DoS attack (âŸ· Denial of Service attack)

sistemin kaynaklarÄ±nÄ± (Ã¶rneÄŸin bant geniÅŸliÄŸi, CPU) tÃ¼ketip, hizmetin kullanÄ±cÄ±lara ulaÅŸmasÄ±nÄ± engellemeye Ã§alÄ±ÅŸan saldÄ±rÄ± tipidir.

Denial-of-service terimi "servis reddi" anlamÄ±na gelir. yani; servis kullanÄ±cÄ±larÄ±nÄ± reddetmektedir (zorunda kalÄ±r).

burada bilgi hÄ±rsÄ±zlÄ±ÄŸÄ± sÃ¶z konusu deÄŸildir.

## ğŸ“Œ DDoS attack (âŸ· Distributed DoS attack)

birÃ§ok makineden paralel DoS ataÄŸÄ± yapma saldÄ±rÄ±sÄ±dÄ±r. DDoS saldÄ±rÄ±larÄ± bazen Botnet aÄŸÄ±ndan, target'a yapÄ±lmaktadÄ±r.

## ğŸ“Œ Hijack attack

Hijack kelime anlamÄ±: hÄ±rsÄ±zlÄ±k.

## ğŸ“Œ Malware (âŸ· malicious software)

category of all dangerous softwares.

## ğŸ“Œ Spyware

kullanÄ±cÄ±dan habersiz arka planda bilgi toplamak amaÃ§lÄ± yazÄ±lmÄ±ÅŸ zararlÄ± uygulamadÄ±r. Ã¶rnek: keylogger.

## ğŸ“Œ Phishing

Password'Ã¼n ilk karakteri ve fishing'in (balÄ±k avlama, oltalama) birleÅŸiminden oluÅŸan bir terimdir.

ÅŸifre gibi bilgileri Ã§almak iÃ§in, gerÃ§ek bir kurumdan geliyormuÅŸ gibi e-posta yada benzeri sayfalar ile hazÄ±rlanan tuzaklara verilen isimdir.

## ğŸ“Œ Social engineering

Sosyal mÃ¼hendislik, internette insanlarÄ±n zafiyetlerinden faydalanarak Ã§eÅŸitli ikna ve kandÄ±rma yÃ¶ntemleriyle istenilen bilgileri elde etmeye Ã§alÄ±ÅŸmaktÄ±r.

## ğŸ“Œ Adware

reklam gÃ¶steren uygulamalardÄ±r.

## ğŸ“Œ Ransomware

Ransom TÃ¼rkÃ§e kelime anlamÄ±: fidye

fidye isteyen yazÄ±lÄ±mlar. genelde sistemde belli ÅŸeyleri ÅŸifrelerler, para karÅŸÄ±lÄ±ÄŸÄ±nda karÅŸÄ±lÄ±ÄŸÄ±nda bilgisayarÄ± tekrar virÃ¼sten arÄ±ndÄ±racaÄŸÄ±nÄ± iddia eder.

## ğŸ“Œ Scareware

Scare kelime anlamÄ±: korkmak

farklÄ± bir yazÄ±lÄ±m yÃ¼kleme vaadiyle (gerÃ§ekten o yazÄ±lÄ±m yÃ¼klenir) kurulup, arka planda kÃ¶tÃ¼ amaÃ§lÄ± farklÄ± yazÄ±lÄ±mlar Ã§alÄ±ÅŸtÄ±ran uygulamalardÄ±r.

## ğŸ“Œ Botnet (âŸ· zombi aÄŸÄ±)

her bilgisayara Botnet dediÄŸimiz bu zararlÄ± yazÄ±lÄ±m yÃ¼klenir. bu zararlÄ± yazÄ±lÄ±m, kurulduÄŸu makineye uzaktan eriÅŸim iÃ§in gÃ¼venlik aÃ§Ä±ÄŸÄ± saÄŸlar. bu ÅŸekilde tek bir noktadan tÃ¼m uzak bilgisayarlar yÃ¶netilebilir olur. bu kurulan network aÄŸÄ±na "zombi aÄŸÄ±" denir. her bilgisayara ise "zombi (âŸ· zombie)" denir.

## ğŸ“Œ backdoor

bilgisayarÄ±n uzaktan yÃ¶netilebilmesi iÃ§in aÃ§Ä±lan gÃ¼venlik aÃ§Ä±ÄŸÄ±na verilen isimdir.

## ğŸ“Œ Trojen (âŸ· Truva atÄ±)

Scareware ile farkÄ± genel olarak yoktur.

## ğŸ“Œ virÃ¼s

otomatik yada kullanÄ±cÄ± tÄ±klamalarÄ±yla farklÄ± makinelere yayÄ±lma Ã¶zelliÄŸi olan malware'lerdir.

## ğŸ“Œ Worm (âŸ· solucan)

baÅŸka makinelere otomatik yayÄ±lÄ±r.

## ğŸ“Œ Brute-force attack (âŸ· kaba kuvvet ataÄŸÄ±)

Sadece deneme yanÄ±lma ile sÃ¼rekli olarak farklÄ± girdilerle doÄŸru Ã§Ä±ktÄ±larÄ± elde etmeye Ã§alÄ±ÅŸma iÅŸlemidir.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ TLS (âŸ· Transport Layer Security) vs SSL (âŸ· Secure Sockets Layer)

AynÄ± protocol'Ã¼n farklÄ± sÃ¼rÃ¼mleridir ama isim deÄŸiÅŸikliÄŸi yaÅŸamÄ±ÅŸtÄ±r.

## ğŸ“Œ SSL version history

| version     | publish date |
|-------------|--------------|
| `SSL` `1.0` | Unpublished  |
| `SSL` `2.0` | 1995         |
| `SSL` `3.0` | 1996         |
| `TLS` `1.0` | 1999         |
| `TLS` `1.1` | 2006         |
| `TLS` `1.2` | 2008         |
| `TLS` `1.3` | 2018         |

ArtÄ±k `TLS` `1.1` ve Ã¶ncesinin resmi olarak gÃ¼vensizdir.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ mTLS (âŸ· Mutual TLS)

`TLS` sadece server tarafÄ±n sertifikasÄ±nÄ± onaylanÄ±r. Oysa `mTLS` hem server hemde client'Ä±n sertifikasÄ±nÄ± onaylanÄ±r.

`mTLS` bir protocol deÄŸil. Genel bir pattern'dir. Yani nasÄ±l yapÄ±lacaÄŸÄ± ile ilgili bilgi iÃ§ermez.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ sunucunun sertifika detaylarÄ±nÄ± gÃ¶rme

BirÃ§ok farklÄ± yÃ¶ntem kullanÄ±labilir:

- https://www.ssllabs.com/ssltest/index.html gibi birÃ§ok site girdiÄŸimiz domain name adresine istek yaparak detaylarÄ± web tarayÄ±cÄ±da bize raporluyor. hangi client'larÄ±n (web tarayÄ±cÄ±, java) sÃ¼rÃ¼mleri ile bu sertifikada sorun Ã§Ä±karÄ±p Ã§Ä±karmayacaÄŸÄ±nÄ± da raporluyor.

- https://badssl.com/ birÃ§ok farklÄ± sertifika iÃ§eren sayfaya linkler iÃ§eriyor. bu ÅŸekilde web tarayÄ±cÄ±mÄ±zÄ±n her sertifika iÃ§in nasÄ±l uyarÄ± verdiÄŸini veya diÄŸer davranÄ±ÅŸlarÄ±nÄ± inceleyebiliyoruz.

- komut satÄ±rÄ± uygulamalarÄ± ile sertifika ve handshake iÅŸlemlerinin detaylarÄ±nÄ± print edebiliriz:
  - openssl s_client -showcerts -connect ma.ttias.be:443
  - curl -vvI <https://gnupg.org>

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ HTTP'den HTTPS'e yÃ¶nlendirme

HTTP ile gidilen site, dÃ¶nÃ¼ÅŸ deÄŸerinde HTTPS'e yÃ¶nlendirme isteÄŸinde bulunur. web tarayÄ±cÄ±da kullanÄ±cÄ±yÄ± HTTPS'e yÃ¶nlendirir.

eÄŸer arada trafiÄŸimizi izleyip manipÃ¼le eden birileri varsa, bu isteÄŸin cevabÄ±nda tarayÄ±cÄ± HTTPS'e yÃ¶nlendirme yapmaz. yapmaz ise, normal HTTP sitenin get isteÄŸinin cevabÄ± ile sayfada gezinilir. artÄ±k son kullanÄ±cÄ± HTTP ile iletiÅŸime devam edeceÄŸi iÃ§in tÃ¼m iletiÅŸim baÅŸtan sona izlenebilir.

## ğŸ“Œ "HTTPS everywhere" vs "smart https"

Web tarayÄ±cÄ± eklentileridir. Smart; her URL'yi sorgulamadan HTTPS'e Ã§evirir. EÄŸer herhangi bir cevap gelirse siteye gider, yoksa HTTP olana gider. Fakat "HTTPS everywhere" her site iÃ§in Ã¶nceden rule set tutar ve aÅŸaÄŸÄ±daki gibi geliÅŸmiÅŸ yÃ¶nlendirmelerde yapabilir.

```text
http://fr.wikipedia.org/wiki/Chose

redirect to --->>

https://secure.wikimedia.org/wikipedia/fr/wiki/Chose
```

## ğŸ“Œ HSTS (âŸ· HTTP Strict Transport Security)

KullanÄ±cÄ±yÄ± HTTP'den HTTPS'e yÃ¶nlendirildiÄŸinde sunucu bu header'Ä± dÃ¶ner:

> Strict-Transport-Security: max-age=16070400; includeSubDomains

max-age sÃ¼resinde tarayÄ±cÄ± son kullanÄ±cÄ± HTTP'ye gitmek istese bile HTTPS'e otomatik yÃ¶nlendirecektir.

## ğŸ“Œ Preloaded HSTS sites

HSTS iÃ§in bir kere olsun siteye gitmek gerekiyor. bunu da yapmaya gerek kalmamasÄ± iÃ§in tÃ¼m web tarayÄ±cÄ±larÄ±n ortak tuttuÄŸu bir liste var:

<https://cs.chromium.org/chromium/src/net/http/transport_security_state_static.json>

dosya iÃ§eriÄŸi Ã§ok bÃ¼yÃ¼k. bir kÄ±smÄ±:

```json
{ "name": "qualitymudjacking.com", "policy": "bulk-1-year", "mode": "force-https", "include_subdomains": true },
{ "name": "qualitypiering.com", "policy": "bulk-1-year", "mode": "force-https", "include_subdomains": true },
{ "name": "qualitypolyjacking.com", "policy": "bulk-1-year", "mode": "force-https", "include_subdomains": true },
{ "name": "qualitywaterproofingco.com", "policy": "bulk-1-year", "mode": "force-https", "include_subdomains": true },
{ "name": "quanquan.space", "policy": "bulk-1-year", "mode": "force-https", "include_subdomains": true },
{ "name": "qulixqa.com", "policy": "bulk-1-year", "mode": "force-https", "include_subdomains": true },
```

Bu listeye kaydolmak Ã¼cretsiz. bu bilgileri web tarayÄ±cÄ±larÄ± sÃ¼rekli lokalde gÃ¼ncel tutuyor ve bu listedeki sitelere gitmek isteyen kullanÄ±cÄ±larÄ± direk HTTPS'e yÃ¶nlendiriyor.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Diffie-Hellman key exchange

known also as:

- `Diffieâ€“Hellman` key agreement
- `Diffieâ€“Hellman` key establishment
- `Diffieâ€“Hellman` key negotiation
- Exponential key exchange
- `Diffieâ€“Hellman` protocol
- `Diffieâ€“Hellman` handshake
- `Diffieâ€“Hellman``-Merkle` `*` (all combinations above)

`Whitfield Diffie` and `Martin Hellman` invented this algorithm.

`Ralph Merkle` is one of the inventor of asymmetric cryptography. `Diffie` and `Hellman` are the inventors of the earliest practical examples of `public key` exchange implemented within the field of cryptography. Therefore `Diffieâ€“Hellman` known as `Diffieâ€“Hellman-Merkle`.

We use key exchange to generate a key (using a not secure connection) which is known only by communicator but not by middle attackers.

Let assume that `Alice` and `Bob` will communicate. They are in key exchange phase. There are many different alternatives for this phase. On this topic we will explain the Diffie-Hellman key exchange algorithm.

"`Eve`" is the name of the middle listener (hacker). `Not`: `Eve` ismi `Ä°ngilizce`'de kulak misafiri anlamÄ±na gelen `eavesdropper`'dan gelir.

`g` and `p` are generated randomly and publicly by `alice` and `bob`.

- `g = public (prime) base`, known to `Alice`, `Bob`, and `Eve`. `g = 5`
- `p = public (prime) modulus`, known to `Alice`, `Bob`, and `Eve`. `p = 23`
- `a = Alice's private key`, known only to `Alice`. `a = 6`
- `b = Bob's private key`, known only to `Bob`. `b = 15`
- `A = Alice's public key`, known to `Alice`, `Bob`, and `Eve`. `A = g^a mod p = 8`
- `B = Bob's public key`, known to `Alice`, `Bob`, and `Eve`. `B = g^b mod p = 19`

`mod` is the `modulo` operation in math.

| `Alice` Known       | `Alice` unknown | `Bob` Known          | `Bob` Unknown | `Eve`  Known  | `Eve` Unknown |
|---------------------|-----------------|----------------------|---------------|---------------|---------------|
| p = 23              |                 | p = 23               |               | p = 23        |               |
| g = 5               |                 | g = 5                |               | g = 5         |               |
| a = 6               | b               | b = 15               | a             |               | a, b          |
| A = 5^a mod 23      |                 | B = 5^b mod 23       |               |               |               |
| A = 5^6 mod 23 = 8  |                 | B = 5^15 mod 23 = 19 |               |               |               |
| B = 19              |                 | A = 8                |               | A = 8, B = 19 |               |
| s = B^a mod 23      |                 | s = A^b mod 23       |               |               |               |
| s = 19^6 mod 23 = 2 |                 | s = 8^15 mod 23 = 2  |               |               | s             |

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ ileri gÃ¼venlik (âŸ· kusursuz ileri gÃ¼venlik âŸ· forward secrecy âŸ· FS âŸ· perfect forward secrecy âŸ· PFS)

her oturum aÃ§Ä±ldÄ±ÄŸÄ±nda veya aynÄ± oturumun farklÄ± zaman aralÄ±klarÄ±nda farklÄ± anahtar ile ÅŸifreleme yapÄ±lma tekniÄŸidir. bu ÅŸekilde, ilgili oturumun anahtarÄ± Ã§alÄ±nsa bile, geriye dÃ¶nÃ¼k data'lar (diÄŸer oturumlarÄ±n data'larÄ±) aÃ§Ä±lamayacaktÄ±r.

Burada ÅŸunlara dikkat edilmelidir:

- her oluÅŸturulan yeni oturum anahtarÄ±nÄ±n, bir Ã¶nceki ile iliÅŸkisel olmamasÄ± gerekir.
- anahtar oluÅŸturma sÄ±klÄ±ÄŸÄ± ne kadar fazla ise riski bi o kadar dÃ¼ÅŸÃ¼rmÃ¼ÅŸ oluruz.
- her oluÅŸturulan yeni oturum anahtarÄ±nÄ±n, client ve server arasÄ±nda paylaÅŸÄ±lÄ±rken, aradaki kÃ¶tÃ¼ niyetli kiÅŸinin iletiÅŸi aÃ§Ä±k ÅŸekilde okuyabilse bile, bu anahtarÄ± bilememesi gerekir (bunun iÃ§in "Diffieâ€“Hellman key exchange" matematiksel algoritmasÄ±na bakÄ±labilir).

"Diffieâ€“Hellman key exchange" iÅŸlemi sonucunda hacker'Ä±n bilmediÄŸi bir anahtar hem client hem de sunucu tarafta oluÅŸturulmaktadÄ±r. Bu key her oturumda farklÄ± kullanÄ±larak "ileri gÃ¼venlik" saÄŸlanmÄ±ÅŸ olur.

YukarÄ±daki duruma web tarayÄ±cÄ±larÄ±ndan Ã¶rnek verelim: web tarayÄ±cÄ± belli kurallara gÃ¶re (belli aralÄ±klarda), "Diffieâ€“Hellman key exchange" kullanarak oturumu her defasÄ±nda ÅŸifrelemektedir.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Open Web Application Security Project (âŸ· OWASP)

OWASP is an online community which creates freely-available articles, methodologies, documentation, tools, and technologies in the field of web application security.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Bot

TÃ¼rkÃ§e ismi de bot'tur. BazÄ± kaynaklarda 'robot' olarak da kullanÄ±lÄ±r.

Otomatik iÅŸlem yapan yazÄ±lÄ±mlardÄ±r. Ã¶rneÄŸin; oyunlardaki botlar benzerdir fakat tam olarak aynÄ± ÅŸey deÄŸillerdir.

## ğŸ“Œ Internet bot

Ä°nternet Ã¼zerinde otomatik iÅŸlem yapan yazÄ±lÄ±mlardÄ±r.

## ğŸ“Œ Web crawler (âŸ· web spider)

Bir Ã§eÅŸit internet botudur. Sadece web sayfalarÄ±nÄ± dolaÅŸan yazÄ±lÄ±mlardÄ±r. Bu dolaÅŸma iÅŸlemi, sitelerin eski hallerini arÅŸivlemek, siteleri arama motorlarÄ± iÃ§in index'lemek, bir siteyi tÃ¼m alt sayfalarÄ± ile download etmek (bazÄ± download manager'lar yapÄ±yor) gibi birÃ§ok amaÃ§ iÃ§in olabilir.

## ğŸ“Œ Web scraper (âŸ· web harvesting âŸ· web data extraction âŸ· Web kazÄ±ma âŸ· web hasat âŸ· web veri Ã§ekimi)

HTML Ã¼zerinde verileri parse edip uygun verileri ayÄ±klamak iÃ§in gerekli yazÄ±lÄ±mdÄ±r. web crawler siteleri gezerken siteleri arka planda indirirler. ardÄ±ndan, web scraper sitelerin iÃ§indeki bilgileri, DB'lere kaydeder.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ string vs char[] for passwords (on java)

ÅŸifreler programda string deÄŸil char[] tutulmasÄ± Ã¶nerilir. bunun bazÄ± sebebleri:

- program exception olup kapanÄ±rsa OS variable'larÄ±n dump'Ä±nÄ± bir yere atar. daha sonra birileri bunu okursa, string deÄŸeri okunabilirken, char[]'in deÄŸeri okunamaz. Ã§Ã¼nkÃ¼ char[]'in toString()'i yoktur.

- char[]'in toString()'i olmadÄ±ÄŸÄ±ndan; biri yanlÄ±ÅŸlÄ±kla log atarsa log("" + password); ekranda ÅŸifre gÃ¶rÃ¼lmeyecektir. birinin direk ÅŸifreyi ekrana basma ihtimali az, fakat obje iÃ§inde obje olduÄŸunda bazen taÅŸÄ±nma iÅŸlemlerinde yanlÄ±ÅŸlÄ±kla log basÄ±lmÄ±ÅŸ olabilir.

- String'ler immutable olduklarÄ±ndan referanslarÄ± olmasa bile garbage collector temizleyene kadar RAM'de tutulurlar. eÄŸer uygulama hack'lenirse RAM'den okuma yapacak olan hacker bu deÄŸerleri gÃ¶rebilir. string ve char[], RAM'den aynÄ± ÅŸekilde okunur, fakat bu maddede bahsedilen, kullanÄ±ma ihtiyaÃ§ duyulmadÄ±ÄŸÄ±nda, string'in memory'den silinmesinin daha uzun zaman alabilmesidir.  http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#PBEEx

Ek not:

- javax.swing kÃ¼tÃ¼phanesinin JPasswordField sÄ±nÄ±fÄ± getText() metodu artÄ±k char[] dÃ¶nÃ¼yor (eskiden string dÃ¶nÃ¼yordu). bu sebepten bÃ¶yle dÃ¼zeltildi.

Ek not:

- `.Net` ortamÄ±nda `System.Security` `namespace`'si altÄ±nda `SecureString` isimli bir sÄ±nÄ±f vardÄ±r. Bu sÄ±nÄ±f aynÄ± bir string gibi davranmakta fakat iÅŸimiz bittiÄŸinde bu sÄ±nÄ±fÄ± "Dispose()" (kelime anlamÄ±: elden Ã§Ä±karmak) metodu ile yok edebiliyoruz. AynÄ± zamanda, burada string memory'de ÅŸifrelenmiÅŸ olarak saklanmaktadÄ±r. ÅŸifreleme gÃ¶revini `.Net` ortamÄ±'Ä± yapmaktadÄ±r.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Luna

Thales (daha eskiden SafeNet) firmasÄ± tarafÄ±ndan geliÅŸtirilen, HSM (Hardware security Module) donanÄ±m ailesidir.

YazÄ±lÄ±msal API'si aracÄ±lÄ±ÄŸÄ± ile network Ã¼zerinden aldÄ±ÄŸÄ± bilgileri ÅŸifreleyip aÃ§abilmektedir.

FarklÄ± sÃ¼rÃ¼mleri ve farklÄ± donanÄ±mlar satarlar.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Content Security Policy (âŸ· CSP)

Web sayfasÄ± `HTML`'inde hangi origin'lerden ne tip kaynaklar (image, JS) indirilebileceÄŸini tanÄ±mlÄ±yoruz. Bu tanÄ±mlarÄ±mÄ±z dÄ±ÅŸÄ±nda istek yollandÄ±ÄŸÄ±nda tarayÄ±cÄ± engel koyuyor.

```html
<meta http-equiv="Content-Security-Policy"
      content="default-src 'self'; img-src https://*; child-src 'none';">
```

AynÄ± ÅŸekilde Content-Security-Policy header'Ä± web sayfasÄ±nÄ±n yÃ¼klendiÄŸi request'te dÃ¶nebilir. yani HTML'de olmak zorunda deÄŸildir.

Not: eÄŸer HTTP response'unda dÃ¶necek ise, tÃ¼m response'larda dÃ¶nmek zorundadÄ±r. sadece index-html'in olduÄŸu request'ten bu header'larÄ±n dÃ¶nmesi yetmez.

### ğŸ“ŒğŸ“Œ Policy'lere Ã¶rnekler

sub domain'ler olmayacak ÅŸekilde tÃ¼m script'ler sadece ÅŸu andaki origin'e yapÄ±labilecektir:

```text
Content-Security-Policy: default-src 'self'
```

Sadece kendine (subdomain'lere istek atamaz) ve trusted.com'un ve onun subdomain'lerinden yÃ¼kleme yapÄ±labilir.

```text
Content-Security-Policy: default-src 'self' trusted.com *.trusted.com
```

A web site administrator wants to allow users of a web application to include images from any origin in their own content, but to restrict audio or video media to trusted providers, and all scripts only to a specific server that hosts trusted code:

```text
Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com
```

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ red team (âŸ· kÄ±rmÄ±zÄ± takÄ±m)

bir ÅŸirkete baÄŸlÄ± ÅŸirketin aÃ§Ä±klarÄ±nÄ± bulmaya Ã§alÄ±ÅŸan ekibe verilen genel isimdir. bu aÃ§Ä±klar sadece yazÄ±lÄ±msal olmayabilir, ÅŸirket Ã§alÄ±ÅŸanlarÄ±na email Ã¼zerinden sosyal mÃ¼hendislik saldÄ±rÄ±larÄ± da yaparlar.

etik hacker'lar bu kategoridedir.

## ğŸ“Œ blue team (âŸ· mavi takÄ±m)

red team'in tersi olarak ÅŸirketi korumaya Ã§alÄ±ÅŸan ekiptir. audit/monitoring sistemleri kurup, takibi ve yÃ¶netimini saÄŸlarlar.

## ğŸ“Œ purple team (âŸ· mor takÄ±m)

red ve blue takÄ±mÄ±n birlikte Ã§alÄ±ÅŸma kÃ¼ltÃ¼rÃ¼ iÃ§in kullanÄ±lan bir terimdir. devops teriminde olduÄŸu gibi bir durum sÃ¶z konusu.

## ğŸ“Œ green team (âŸ· yeÅŸil takÄ±m)

blue team'in bulduÄŸu aÃ§Ä±klarÄ± kapatmak iÃ§in yazÄ±lÄ±m geliÅŸtirirler.

## ğŸ“Œ white team (âŸ· beyaz takÄ±m)

kÄ±rmÄ±zÄ± ve mavi takÄ±m kapÄ±ÅŸmalarÄ±nda hakemlik yapar. sonuÃ§larÄ± deÄŸerlendirir, kapÄ±ÅŸmalardaki kurallarÄ± belirler...

## ğŸ“Œ black hat (âŸ· black hat hacker âŸ· blackhat)

kÃ¶tÃ¼ niyetli (illegal) hacker.

## ğŸ“Œ grey hat (âŸ· greyhat âŸ· gray hat)

illegal olmayabilirler fakat, illegal iÅŸ yaptÄ±klarÄ±nda Ã§ok bÃ¼yÃ¼k suÃ§ iÅŸlemezler.

ÅŸu gibi kiÅŸiler iÃ§in bu terim kullanÄ±lÄ±r:

- keÅŸfettiklerinde Ã¼rÃ¼nÃ¼n sahibine bunun nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± sÃ¶ylemek yerine, onu kÃ¼Ã§Ã¼k bir Ã¼cret karÅŸÄ±lÄ±ÄŸÄ±nda onarmayÄ± teklif edebilirler.
- firmalara ders vermek amacÄ± ile, yazÄ±lÄ±mlardaki aÃ§Ä±klarÄ± direk public olarak yayarlar.

## ğŸ“Œ white hat (âŸ· a white-hat hacker âŸ· whitehat)

ethical hacker.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Security through obscurity (âŸ· security by obscurity)

obscurity kelime anlamÄ±: belirsizlik, bilinmezlik.

gÃ¼venliÄŸi saÄŸlarken, gÃ¼venlik mekanizmasÄ±nÄ±n nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± fark ettirmemeye Ã§alÄ±ÅŸÄ±lmasÄ±dÄ±r. Ã¶rnekler:

- JS kodlarÄ±nÄ± Ã¶nyÃ¼ze dÃ¶nerken, kodlardaki isimlendirmeleri karmaÅŸÄ±klaÅŸtÄ±rmak.
- DB tablolarÄ±mÄ±zdaki sÃ¼tun isimlerini gerÃ§ek anlamlarÄ±ndan farklÄ± yaparak, hacker'larÄ± ÅŸaÅŸÄ±rtmaya Ã§alÄ±ÅŸmak.

bunlarÄ± yapmak fayda saÄŸlayabilir fakat bu temelde buna dayanarak gÃ¼venlik kesinlikle saÄŸlanmamalÄ±dÄ±r. gÃ¼venlik Ã¶yle olmalÄ±dÄ±r ki; metodolojisi bilinse bile, anahtarlarÄ±mÄ±z Ã§alÄ±nmadÄ±ÄŸÄ± takdirde kÄ±rÄ±lamamalÄ±dÄ±r (Kerckhoffs's principle).

## ğŸ“Œ Kerckhoffs's principle (âŸ· Kerckhoffs ilkesi)

"principle" in title can be referred also as: desideratum, assumption, axiom, doctrine, law

baÅŸlÄ±ktaki "ilke" bunlarla da kullanÄ±lmaktadÄ±r: sanÄ±, aksiyom, yasa

Kerckhoffs ilkesi ÅŸunu der: ÅŸifreleme kullanan bir sistem, anahtar hariÃ§, sistemle ilgili her ÅŸey bilinse bile gÃ¼venli olmalÄ±dÄ±r.

## ğŸ“Œ Secure by design

gÃ¼venlik aÃ§Ä±klarÄ±na tek tek spesifik kapatmak yerine, kÃ¶kten (mimarisel) Ã§Ã¶zÃ¼m bulan mimarilere "secure by design" denir. yani dizaynÄ±n kendisi zaten gÃ¼venlidir. Ã¶rneÄŸin;

- web tarayÄ±cÄ±sÄ± hack'lenebilir. bunun iÃ§in birÃ§ok gÃ¼venlik yÃ¶ntemi ekleyebiliriz. fakat eÄŸer tarayÄ±cÄ±nÄ±n kendisi, Android Ã¼zerinde hiÃ§bir yetki kullanmadan Ã§alÄ±ÅŸÄ±r ise; tarayÄ±cÄ± hack'lense bile, hacker dÄ±ÅŸ kaynaklara eriÅŸemeyecektir.
- sanal paralarÄ± gÃ¼venli kÄ±lan Ã¶zelliklerin sistemin kendisi baÅŸtan iyi tasarlanmÄ±ÅŸ olmasÄ±dÄ±r. sanal para sahipleri kendi paralarÄ±nÄ±n deÄŸerinin kaybolmamasÄ± iÃ§in diÄŸer sanal para sunucularÄ± (node'larÄ±) ile uyumlu Ã§alÄ±ÅŸma durumundadÄ±rlar.
- ORM kullanÄ±nca zaten SQL injection'Ä± komple engellemiÅŸ oluruz. Tek tek her type (number, string) iÃ§in SQL korumasÄ±/validasyonu yazmayÄ±z.
- CQRS yapÄ±nca Read-only servislerimizde doÄŸal yoldan koruma saÄŸlamÄ±ÅŸ oluruz.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ security vs privacy vs anonymity

- Those are 3 different terms.
- Security means that the system protects you from hacks.
- Privacy means that the system protects your personal data. Every private system has to be secure, but not visa versa. For example WhatsApp use the same protocol as Signal messenger. The protocol is also called "Signal". Signal protocol is secure, therefore both WhatsApp and Signal are secure too. But Signal messenger is private, but WhatsApp is not. Because (we assume) WhatsApp can (may) store your `private key`s (which are using on Signal protocol) in their servers and can give other government authorities in some legal cases. Also WhatsApp can (may) sell your messages with your identity to advertisement companies or any other 3rd parties (because WhatsApp is a private company).
- Anonymity means that the system protects your personal identity. In order to do that it should be secure and private.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Zero trust architecture (âŸ· ZTA âŸ· perimeterless security)

`Perimeter` kelime anlamÄ±: SÄ±nÄ±r, Ã§evre hattÄ±.

internal network'te olsa bile, hiÃ§bir cihaza veya kullanÄ±cÄ±ya gÃ¼venmeyip doÄŸrulama yapan mimariler iÃ§in kullanÄ±lan terimdir.

Ã¶rnekler:

- API gateway gelen `JWT`'yi aÃ§Ä±p, internal'da aÃ§Ä±k yollamamalÄ±. Her microservice kendi `JWT`'yi aÃ§malÄ±.
- internal'da her microservice `TLS` ile haberleÅŸmeli.
- `mTLS`

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

## ğŸ“Œ Open-source intelligence (âŸ· OSINT)

Public olarak yayÄ±mlanan data'lardan istihbarat elde etme yÃ¶ntemidir.

TV, radyo, gazete, sosyal medya gibi kaynaklardan yararlanÄ±lÄ±r.

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢

â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢
