
# PATTERN DOMAIN DRIVEN DESIGN

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII

## üìå Kitap

DDD ilk olarak Eric Evans tarafƒ±ndan "Domain-Driven Design: Tackling Complexity in the Heart of Software" kitabƒ±nda, 2003 yƒ±lƒ±nda ortaya atƒ±lmƒ±≈ütƒ±r. Bu kitaba piyasada "The Big Blue Book" da denilmektedir. Daha sonra, 2014'te Eric, tanƒ±mlarƒ±n referanslarƒ±nƒ± kƒ±saca yazdƒ±ƒüƒ± "Domain-Driven Design Reference: Definitions and Pattern Summaries" isimli kitapta √∂zetlemi≈ütir ve eski kitabƒ±na √ßok ufak eklemeler yapmƒ±≈ütƒ±r. Bu yeni eklemeler √∂zellikle kitabƒ±n title index'inde her ba≈ülƒ±kta yƒ±ldƒ±zlƒ± ≈üekilde belirtilmi≈ütir. Bu yeni eklemeler ≈üunlardƒ±r:

- Domain Events
- Partnership (from "Context Mapping")
- Big Ball of Mud (from "Context Mapping")

DDD 2003 kitabƒ±nda bir√ßok √∂neri/pattern'den bahsedilmektedir. Bunun yanƒ±nda;

- continuous integration
- Refactoring
- Clean&Readable code/architecture (not specific implementation examples - but more architectural like how to separate each class...)
- Factory sƒ±nƒ±flarƒ±
- takƒ±m √ßalƒ±≈ümasƒ±nƒ±n √∂nemi
- side effect free functions

gibi konularƒ±n √∂nemlerine bir kez daha bu kitapta √∂zellikle deƒüiniliyor. zaten √ßoƒüu bilgi kitap ilk yazƒ±ldƒ±ƒüƒ±nda piyasada bilinmiyordu. Bu konular DDD √ßalƒ±≈ümasƒ± i√ßinde temel olu≈üturduƒüu i√ßin bu konularda kitapta yer almƒ±≈ütƒ±r.

## üìå Bu d√∂k√ºmandaki bilgilerin kaynaƒüƒ±

Bu d√∂k√ºmanda her bilgi sadece DDD'nin ilk kitabƒ±na dayanmƒ±yor. Farklƒ± kaynaklardan da yararlanƒ±lmƒ±≈ütƒ±r.

## üìå ne zaman kullanƒ±lmalƒ±

Business logic'in fazla olduƒüunda tercih edilir.

## üìå ubiquitous language

ubiquitous kelime anlamƒ±: yaygƒ±n

Domain expert'leri ve yazƒ±lƒ±mcƒ±lar ortak isimlendirme kullanmalƒ±dƒ±r. isimlendirmeler teknik deƒüil; domain uzmanlarƒ±nƒ±n verdiƒüi isimler olmalƒ±dƒ±r. bu isimlendirmeye "ubiquitous language" adƒ± verilmi≈ütir.

## üìå Domain-driven design (‚ü∑ DDD) vs data-centric design (‚ü∑ database-centric design ‚ü∑ data-driven design)

DDD, __domain-centric design__ mantƒ±ƒüƒ±na dayalƒ±dƒ±r.

Kar≈üƒ±la≈ütƒ±rma:

- DDD'de, business tarafƒ±nda DB'den hi√ß habersiz (__persistence ignorance__) geli≈ütirme ba≈ülanmalƒ±dƒ±r ve devam ettirilmelidir. Oysa data-centric'te bunun tersi √∂nerilir.
- DDD'de Domain ve persistence DB'deki modellerimiz farklƒ± olabilir. Oysa data-centric'te bunun tersini √∂nerilir.

Yukarƒ±daki maddeleri ≈üuradan √ßƒ±karabiliriz: book: "Patterns, Principles, And Practices Of Domain-Driven Design", authors: "Scott Millett" and "Nick Tune", title: "Domain Model Implementation Patterns", subtitle: "domain model", 63 page, 1st paragraph.

Bazƒ± domain'lerde (√∂rneƒüin; metric/istatistik, yapay zeka sistemlerinde) DDD yerine, data-centric mimariler kullanmak daha verimli olabiliyor.

## üìå business katmanƒ± VS repository implementasyonu (persistence katmanƒ±)

DDD kitabƒ±nda repository'lerin sadece aggregate root'larƒ± √ºzerinde i≈ülem yapmasƒ± gerektiƒüinden bahsedilmi≈ü. Bazen bazƒ± kod bloklarƒ±nƒ±n repository implementasyonlarƒ±mƒ±zda mƒ±, yoksa business logic'lerin olduƒüu servislerde mi olacaƒüƒ± karƒ±≈ümaktadƒ±r. √ñrneƒüin bir data'yƒ± silmeye kalktƒ±ƒüƒ±mƒ±zda, √∂nce onunla baƒülantƒ±lƒ± data'larƒ± silmemiz gerekmektedir. ƒ∞≈üte bu kod bloƒüu repository tarafƒ±nda olmalƒ±dƒ±r. Burada ≈ü√∂yle d√º≈ü√ºnmek lazƒ±m: Eƒüer ki; DB tarafƒ±nda √ßok farklƒ± bir yapƒ± kullanƒ±yor olsaydƒ±k, bu kod bloƒüu deƒüi≈üecek miydi? DB deƒüi≈ütiƒüinde, domain'in bundan haberi olmamasƒ± gerektiƒüi i√ßin, bu kod bloƒüunu repository tarafƒ±na √ßekmeliyiz. Ger√ßek bir √∂rnekten gidersek; RDBMS kullandƒ±ƒüƒ±mƒ±zƒ± varsayalƒ±m. Fakat bunun yerine ileride 1 entity'ye ait t√ºm ili≈ükileri Cassandra'da tek 1 tablo i√ßerisinde tutabiliriz. Bu durumda domain'in deƒüi≈ümemesi lazƒ±m. Bu sebeple, bahsedilen kod bloƒüu repository altƒ±nda olmalƒ±dƒ±r. Tabi burada ince bir nokta daha var: Domain servisleri, repository metotlarƒ±nƒ± √ßaƒüƒ±rƒ±rken, ili≈ükili data'larƒ± ayrƒ± ayrƒ± silineceƒüini bildirmez, sadece aggregate root'un son halini yollar ve bunun silineceƒüini belirtir:

```java
// pseudo code √∂rneƒüi

// compatible with DDD:
repository.save( orderInstanceDomainObject );

// "Repository" implementations may have inside anything like JPA-Entities.
```

## üìå 4 Layers of DDD

DDD'de bir sistem 4 temel katman bulunmalƒ±dƒ±r (kaynak: "Eric Evans", "DDD", "Layered Architecture" ba≈ülƒ±ƒüƒ±.):

- __User Interface (‚ü∑ Presentation Layer)__: web servislerinin bulunduƒüu, √∂ny√ºzlerin bulunduƒüu kodlar.

- __Application__: bu kƒ±sƒ±m use case'leri i√ßerir. bu kƒ±sƒ±mda business logic yoktur. Controller'larƒ±mƒ±zƒ±n gittikleri ilk servisler burasƒ±dƒ±r diyebiliriz.

  G√∂revlerine bazƒ± √∂rnekler;
  - farklƒ± client'lar i√ßin yapƒ±lan transformation ve validasyon i≈ülemleri yapƒ±labilir.
  - UnitOfWork, transactional gibi y√∂netimlerin t√ºm√ºn√º bu katman yapar.
  - Dƒ±≈ü d√ºnyaya data d√∂neceƒüi zaman, domain-objelerini d√∂nmez. Bunlarƒ± DTO'ya √ßevirir. Dƒ±≈üarƒ±ya DTO d√∂ner.
  - Domain grubu i√ßinde olan kodlarƒ± √ßaƒüƒ±rƒ±r. bu kƒ±sƒ±m high-level'dƒ±r.

- __Domain__: bu kƒ±sƒ±m business logic'lerin olduƒüu kƒ±sƒ±mdƒ±r.

- __Infrastructure__: diƒüer hizmetlerin (mail, database...) bulunduƒüu servisler/kodlar. Bu kƒ±sma aynƒ± zamanda ORM mapper'larda dahildir.

Yukarƒ±daki her maddenin ayrƒ±mƒ± i√ßin kaynak: "Eric Evans", "DDD", ≈üekil: "Figure 4.1. Objects carry out responsibilities consistent with their layer and are more coupled to other objects in their layer.".

## üìå Domain types

- __subdomain__

  Domain: e-commerce, sub-domain: checkout, order.

  bir domain'de birden fazla subdomain olabilir. bir sub-domain'de birden fazla bounded context olabilir.

  best-practice'lere g√∂re 1 bounded-context, 1 sub-domain'e denk gelmelidir. Fakat bunu yapmak √ßok zordur.

- __core domain__

  bir doktor i√ßin yazƒ±lƒ±m d√º≈ü√ºnelim. Temelde 2 ihtiya√ß var: 1-randevu sistemi, 2-hastalarƒ±n bilgileri

  Burada core domain 2inci oluyor. √á√ºnk√º; hastalarƒ±n bilgilerini tutma, tahlil sonu√ßlarƒ±nƒ± g√∂stermek temel ama√ß. Bu sebeple "randevu" domain'i, __supporting domain__'dir.

- __generic subdomain__

  user-management, file-archive gibi core domain bilgisi hi√ß gerektirmeyen katmanlar, "generic domain" olarak adlandƒ±rƒ±lƒ±yor. Bunlar bazen 3√ºnc√º parti servisler olabilir, dƒ±≈üarƒ±dan satƒ±n alƒ±nabilir yazƒ±lƒ±mlar olabilir...

## üìå bounded context

Bir model herkes i√ßin farklƒ± g√∂r√ºnebilir.

√∂rnek-1; USB ile satƒ±lan bir Java yazƒ±lƒ±mƒ±; aynƒ± ≈üirkette;

- satƒ±≈ü departmanƒ± i√ßin satƒ±lacak "√ºr√ºn"
- lojistik departmanƒ±nda "kargo"
- yazƒ±lƒ±mcƒ± i√ßinse bir "jar dosyasƒ±"dƒ±r

√∂rnek-2; her kullanƒ±cƒ±; aynƒ± ≈üirkette;

- security-manager i√ßin user
- order-management i√ßin customer
- customer i√ßin bir diƒüer customer, referans edebileceƒüi ki≈üi'dir (loyalty kapsamƒ±nda).

Yani; her birimde'te, aynƒ± model, farklƒ± field'larla temsil edilebilir. √á√ºnk√º her birimin t√ºm alanlara ihtiyacƒ± olmayabilir veya bir alanƒ± farklƒ± tipte tutmak isteyebilir. yani; her model bir birim i√ßerisinde bound edilmi≈ütir (sƒ±nƒ±rlandƒ±rƒ±lmƒ±≈ütƒ±r).

Eƒüer bir model ba≈üka bir birime yollanacak ise, map'lenmelidir. Bu konu "context mapping" ba≈ülƒ±ƒüƒ±nda anlatƒ±lmaktadƒ±r.

## üìå example grouping of all services

A≈üaƒüƒ±daki aggregate root'lar 1 microservice olsun dedik, √ß√ºnk√º aggregate-root atomic transaction'da y√∂netilmeli.

- checkout __(domain)__ (composition root - logical concepts)
  - basket __(domain)__ (aggregate root) (1 microservice)

    Bunun altƒ±ndakiler moduler monolithic yapƒ±da olabilir ve/veya hepsinin ayrƒ± bounded-context'i de olabilir.

    - kampanyalar __(subdomain)__ (core domain)
    - gift    __(subdomain)__ (core domain)
    - kupon   __(subdomain)__ (core domain)
    - product __(aggregate)__ (core domain)
  - delivery __(domain)__ (aggregate root) (1 microservice)
  - payment __(domain)__ (aggregate root) (1 microservice)
  - order __(domain)__ (aggregate root) (1 microservice)
- user __(generic domain)__ (1 microservice)
- product-search __(core domain)__ (1 microservice)

## üìå defining the bounded contexts

bounded context'lere ayƒ±rma i≈üinin resmi bir standardƒ± yoktur. bu i≈ü biraz da sezgisel (heuristic) yapƒ±lƒ±r. Bounded context'lere ayƒ±rma i≈ülemi yapƒ±lƒ±rken bazƒ± dikkat edilecek noktalar ≈üunlardƒ±r:

- uygulama geli≈ütirme s√ºreci ilerledik√ße aynƒ± isimler farklƒ± field ve/veya model'lerde kar≈üƒ±mƒ±za √ßƒ±kmaya ba≈ülar. Bu durumda acaba bunlar farklƒ± bounded context'lerde mi olmalƒ± diye d√º≈ü√ºnmeliyiz.
- Yapƒ±lacak i≈üin √∂zelliƒüine g√∂re deƒüil, i≈ü mantƒ±ƒüƒ±na g√∂re belirlenmelidir.
- transaction s√ºreci g√∂z √∂n√ºnde bulundurulabilir. bir deƒüi≈üken deƒüi≈üip, diƒüer modeli de senkron deƒüi≈ütiriyorsa, o t√ºm modeller aynƒ± bounded context'te mi olmalƒ±dƒ±r diye d√º≈ü√ºnmek lazƒ±m.

## üìå context map/mapping

bounded context'ler arasƒ± model ili≈ükilerinin nasƒ±l y√∂netileceƒüi i√ßin disiplinleri belirler. Bu disiplinlerin bazƒ±larƒ± a≈üaƒüƒ±da listelenmi≈ütir.

Context mapping farklƒ± bounded context'ler arasƒ± modellerin ili≈ükilerini g√∂steren bir d√∂k√ºmandƒ±r. (source-id: 477) book:"Domain Driven Design Quickly", authors:"Abel Avram", "Floyd Marinescu", page:73, writes:

> A Context Map is a document which outlines the different Bounded Contexts and the relationships between them. A Context Map can be a diagram like the one below, or it can be any written document. The level of detail may vary. What it is important is that everyone working on the project shares and understands it.

- Partnership

  iki context'i geli≈ütiren ekip birbirinin projeleri i√ßin uygun/uyumlu ≈üekilde ortak kararlarla modellerini g√ºnceller.

- Shared kernel

  farklƒ± bounded context'ler ortak model direk kod olarak payla≈üabilir. bu JAR/DLL payla≈üarak olabilir... √∂rneƒüin sadece "customer" modeli 2 bounded context i√ßin ortak ise bu yol izlenebilir.

- Customer/Supplier Development Teams

  bounded context'deki takƒ±mlardan biri customer biri supplier rol√ºndedir. Bir takƒ±m diƒüer takƒ±mdaki deƒüi≈üiklikleri izler ve planlayarak kendine alƒ±r. Burada direk modeli "hemen kabul etme" ili≈ükisinden ziyade, iki m√º≈üteri-tedarik√ßi rollerinde bir √ßalƒ±≈üma modeli s√∂z konusudur.

- Conformist

  iki servisteki ekipler birbiri ile ortak √ßalƒ±≈üamƒ±yor ise, 1 ekip diƒüerinin yaptƒ±ƒüƒ± her deƒüi≈üikliƒüi almak zorunda olduƒüu durumdur. 1 ekip diƒüer ekibi hi√ß d√º≈ü√ºnmeden modellerini g√ºnceller.

- Anticorruption Layer

  bir context diƒüer context'teki ile uyu≈ümazlƒ±klar ya≈üayabilir. bu durumda en iyi √ß√∂z√ºm; herkesin tamamen kendi modelini olu≈üturmasƒ± ve olabildiƒüince birbirinin field'larƒ±na baƒüƒ±mlƒ± kalmayacak ≈üekilde servis istekleri hazƒ±rlanmalƒ±dƒ±r. Bunun i√ßin adapter (integration layer) yazƒ±lmasƒ± gerekmektedir.

- Open Host Service

  Daha √ßok public API a√ßan hizmetlerdeki gibi bir √ßalƒ±≈üma modeli s√∂z konusudur.

- Published Language

  calendar syntax, contact sync, authentication standards (√∂rnek: OAuth) gibi sistemler buna g√ºzel birer √∂rnektir. Belli d√∂k√ºmantasyona/standartlara uyan modellerle √ßalƒ±≈üƒ±ldƒ±ƒüƒ±nda, API'lere de zaten dolaylƒ± yoldan uymu≈ü olacaƒüƒ±nƒ±z sistemlerdir.

- Separate Ways

  Ortak bir √ßalƒ±≈ümanƒ±n m√ºmk√ºn olmadƒ±ƒüƒ± takƒ±mlarda artƒ±k tamamen farklƒ± yollara gidilebilir. Hi√ßbir ≈üekilde ortam model payla≈üƒ±mƒ± yapƒ±lmaz.

- Big ball of mud

  kelime anlamƒ±: b√ºy√ºk √ßamur topu.

  Burada hi√ßbir pattern uygulanmamaktadƒ±r. Takƒ±mlar birbirlerine haber vererek doƒüa√ßlama bir √ßalƒ±≈üma tekniƒüi izlerler. √ñnerilen bir y√∂ntem deƒüildir.

## üìå microservice vs bounded context

- DDD mimarisinde, microservice ile ilgili bir bilgi yoktur. DDD, `modular monolithic` bir yazƒ±lƒ±mda da kullanƒ±labilir.
- Bazƒ± durumlarda 1 microservice tek ba≈üƒ±na bir bounded context'i temsil edebilirken, birden fazla microservice birlikte 1 bounded context'i temsil edebilir. kaynak: (source-id: 231) "Bir Bounded Context == Bir Mikroservis ?" ba≈ülƒ±ƒüƒ±. + (source-id: 232) 1inci paragrafƒ±n sonu.
- 1 domain birden fazla microservice'ten meydana gelebilir. Veya tam tersi de olabilir.

Genelde beklenen ≈üu yapƒ±dƒ±r:

Domain > Bounded context > Microservice

1 microservice'te 1'den fazla domain veya bounded context olabilir ama pek tercih edilmez. Bu durum microservice'in temel baƒüƒ±msƒ±zlƒ±k arg√ºmanƒ±nƒ± biraz kƒ±rar.

Eƒüer 1 bounded context 1 microservice'te olursa, o microservice'in ne yaptƒ±ƒüƒ±, sorumluluk ayrƒ±mƒ±, transaction y√∂netimi √ßok netle≈üir.

## üìå servisler

objelerin doƒüasƒ±nda olmayan yazƒ±lƒ±msal s√ºre√ßler, "servis" olarak tasarlanmalƒ±dƒ±r.

## üìå Aggregate vs Aggregate Root

1 aggregate, 1 aggregate root i√ßerir. "Aggregate" bir ≈üeylerin b√ºt√ºn olarak kullanƒ±lmasƒ±nƒ± temsil eden genel bir terim. Biz DDD'de bunu pratiƒüe d√∂kt√ºƒü√ºm√ºzde, kar≈üƒ±mƒ±za "aggregate root" kavramƒ± √ßƒ±kar.

Farklƒ± bir deyi≈ü ile; birden fazla entity'nin transaction'larda birlikte uyumlu ≈üekilde i≈ü akƒ±≈üƒ±nƒ± tamamlamalarƒ± gerekir. birden fazla entity'nin birlikte kullanƒ±lmasƒ± durumu "__aggregate__" olarak ifade edilmektedir. yani aggregate, entity'ler grubudur.

"__aggregate root__" ise; direk √∂rnek √ºzerinden gidersek: "sipari≈ü" bir 'aggregate root'tur. ancak sipari≈üe baƒülƒ±, '√∂deme bilgisi', 'kargo bilgisi' entity'ler aggregate root'a baƒülƒ± (normal) entity olarak nitelenirler.

Sipari≈üe baƒülƒ± '√∂deme bilgileri', 'kargo bilgisi' bazƒ± durumlarda (bazƒ± domain'lerde) aynƒ± aggregate root'a baƒülƒ± olmayabilir. Fakat "sipari≈ü kalemi (yani bir sipari≈üteki her item)", "sipari≈ü" aggregate root'unun altƒ±nda olmasƒ± bu konuya daha net bir √∂rnek olarak verilebilir.

ƒ∞nternetteki kaynaklarda bazen, Aggregate ve Aggregate root birbiri yerine kullanƒ±lmaktadƒ±r. √á√ºnk√º biri soyut diƒüeri DDD'ye √∂zel bir implementasyondur.

aggregate root; repository tarafƒ±ndan y√∂netilir ve client bir data load ettiƒüinde ancak aggregate root'a eri≈üebilir. kaynak: (source-id: 233) answer of Jeff Sternal at Dec 24 '09 at 15:33. Fakat pratik'te b√∂yle kod yazƒ±lmaz. genelde client'a sadece ihtiyacƒ± olan data kƒ±smƒ± yollanƒ±r. bu durum anti-pattern deƒüildir. client i√ßin gerektik√ße optimizasyon yapƒ±labilir.

```java
public class Order { // this is the "aggregate root" which has all information about "aggregate".

  UUID orderId;

  long orderNumberForEndUser;

  boolean disabled;

  List<OrderItem> orderItemList; // this is "domain object/domain entity".
  // all other domain objects (like orderItem) should be added here as an object, not ID!

  // Customer is another aggregate root. Therefore customer should not be added as object. It should be ID.
  long customerId;

  // Customer is another "root aggregate". Therefore we should not use the below fields on this class:
  // String customerName; // Which is inside Customer.
  // Customer customer; // this is another aggregate root.
  // Address customerAddress; // this is another domain object which is inside Customer.

  // "getter" and "setter" should be here...
  // "setters" ve "getter" fonksiyonlarƒ± dƒ±≈üarƒ±ya zorunlu olmadƒ±k√ßa a√ßƒ±lmamalƒ±. Daha doƒürusu a√ßƒ±labilir, fakat "getter" ile private field'ƒ±
  // √ßekip ba≈ükasƒ± o private field i√ßerisinde i≈ülem yapamamalƒ±. Aggregate root'u, Object-oriented programlamada olduƒüu gibi
  // sadece public metotlarƒ± ile i≈ülem yapmalƒ±yƒ±z. Yani Order i√ßerisindeki domain objeleri √ºzerinde manip√ºlasyon sadece Aggregate Root'un
  // metotlarƒ± aracƒ±lƒ±ƒüƒ± ile olmalƒ±dƒ±r. √ñrneƒüin tem eklemek isteyen client a≈üaƒüƒ±daki metodu tercih etmeli.

  boolean addItem(OrderItem orderItem){

      if(disabled == true){
        return false;
      }

      if(orderItemList == null){
        orderItemList = new ArrayList<>();
      }

      if(orderItemList.size() > 999){
         throw new OrderException("You can not add more then 999 items to basket!");
      }

      orderItemList.add(orderItem);

      // This is "domain event".
      // For event management Kafka can be used or Spring-event (application itself). By this way, other aggregates may effected by this operation.
      // It is optional to publish an event for each business method.
      // "eventToPublish" method does not publish the event directly. It adds the event to list. This event list should be publish directly after we save the Order Aggregate to DB. (This process should be transactional. "Outbox pattern" can be used.) (for the source check below note-1)
      eventToPublish( new OrderItemAddedEvent(orderItem) );

      return true;
  }

  // All other business logic specific to Order should be here...

  // All the data and method of this class should be "persistence agnostic".

  // Only "Order" can be sent to "repository" to save/update...
  // OrderItem should not sent to "repository". There should not be "OrderItemRepository" on the whole application code.
  // (exceptional cases may happen for performance issues).

  // repository.save(order) method should be called from services or another layers.

  // Order should be saved transactional (via repository). Therefore the events (like OrderItemAddedEvent) should never publish before the transaction will success. (To achieve this gap, if we use microservices we can prefer outbox pattern.)
}
```

source for above (note-1):

<https://github.com/Sairyss/domain-driven-hexagon> title:"Domain Events", sentence: "typeorm.repository.base.ts - repository publishes all domain events for execution when it persists changes to an aggregate.". The link "typeorm.repository.base.ts" redirects here: <https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/libs/ddd/infrastructure/database/base-classes/typeorm.repository.base.ts> On this class we can see below code:

```typescript
async saveMultiple(entities: Entity[]): Promise<Entity[]> {
    const ormEntities = entities.map(entity => {
      entity.validate();
      return this.mapper.toOrmEntity(entity);
    });
    const result = await this.repository.save(ormEntities);
    await Promise.all(
      entities.map(entity =>
        DomainEvents.publishEvents(entity.id, this.logger, this.correlationId),
      ),
    );
    this.logger.debug(
      `[${entities}]: persisted ${entities.map(entity => entity.id)}`,
    );
    return result.map(entity => this.mapper.toDomainEntity(entity));
  }
```

## üìå separating the business logics of Aggregate methods

bir √∂rnek √ºzerinden gidelim:

```java
public class Order { // this is the "aggregate root" which has all information about "aggregate".

  public void disableOrder(){

    order.setDisabled(true);
    order.revertBonus();

    // optionally other business logic here...
    // optionally preparing domain events here...
  }

  private void setDisabled(boolean newStatus){
    this.disabled = newStatus;
  }

  public void revertBonus(){
    // revert the bonus (points) from user.
  }

  // other methods here...
```

Yukarƒ±daki Aggregate'i kullanan kod bloƒüu ≈üu ≈üekilde i≈ülem yapmamasƒ± gerekiyor:

```java
order.setDisabled(true);
order.revertBonus();
```

Bu sebeple setDisabled metodu private yapƒ±ldƒ±. Yani disableOrder metodu bir facade g√∂revi g√∂r√ºyor. Fakat bazƒ± durumlarda sadece revertBonus yapƒ±labileceƒüi i√ßin revertBonus public olarak bƒ±rakƒ±ldƒ±.

Tabi bu durum tamamen business'a baƒülƒ±. Yani; bu kuralƒ±n kesin ve her zaman bu ≈üekilde doƒüru olduƒüunu varsayarak yukarƒ±daki kodu yazdƒ±k: "Eƒüer bir sipari≈ü iptal ediliyor ise mutlaka o sipari≈üten kazanƒ±lan bonus'lar geri alƒ±nmalƒ±dƒ±r.".

## üìå Domain Services vs Application Service

Service kavramƒ± √ßok geneldir. 2'ye b√∂l√ºn√ºr:

- Domain Servisler, aggregate'lerin doƒüasƒ±nda olmayan metotlarƒ±n toplandƒ±ƒüƒ± s√ºre√ßleri kapsayan sƒ±nƒ±flar olmalƒ±dƒ±r.

  Servis sƒ±nƒ±flarƒ±n √ßok olmasƒ± ve/veya Aggregate'lerin i√ßindeki metotlarƒ±n servislerde bulunmasƒ± iyi bir durumun g√∂stergesi deƒüildir.

  Domain servis'lerin state'i olmamasƒ±na gayret edilmelidir.

- application service, domain service ile farkƒ±nƒ± "4 Layers of DDD" ba≈ülƒ±ƒüƒ±ndan √ßƒ±karabiliriz.

## üìå Domain Events

Bu konuya event-sourcing ba≈ülƒ±ƒüƒ±nda da deƒüinildi.

teknik isimde olmamalƒ±dƒ±rlar. domain expert'leri de anlamalƒ±dƒ±r.

Teknik anlamda konu≈üursak; domain event'leri, (farklƒ± veya aynƒ± "bounded context" i√ßindeki) aggregate'lerin birbirleri ile haberle≈ümesi (bir aggregate'teki deƒüi≈üiklik, farklƒ± bir aggregate'te de deƒüi≈üiklik gerektirdiƒüinde) durumunda fƒ±rlatƒ±lan event'lerdir.

### üìåüìå when to publish

Domain event'lerin tam olarak ne zaman fƒ±rlatƒ±lacaƒüƒ± Aggregate kod √∂rneƒüinde belirtildi.

### üìåüìå who can handle

Bir domain event ≈üunlar tarafƒ±ndan handle edilebilir:

- aynƒ± bounded context i√ßindeki bir aggregate-root tarafƒ±ndan.
- farklƒ± bounded-context tarafƒ±ndan.
- farklƒ± domain tarafƒ±ndan (√∂nerilmez. source: <https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation> title:"What is a domain event?", paragraph: 1,8,9.)

### üìåüìå can be sync or async

Domain event'ler senkron veya asenkron olabilirler. Fakat "Integration event"leri kesinlikle asenkron olmak zorundadƒ±r. source: <https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation> title:"What is a domain event?", paragraph: 9.

## üìå integration events

domain dƒ±≈üƒ±ndaki yerlere yollanan event'lerdir. source: <https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation> title:"Domain events versus integration events", paragraph: 2.

## üìå DDD kitabƒ±nda ge√ßen bazƒ± terimler

A≈üaƒüƒ±daki bazƒ± terimleri direk olarak kitap i√ßerisinde a√ßƒ±klanmƒ±≈ü.

## üìå domain

domain is the field for which a system is built. Airport management, insurance sales, coffee shops...

## üìå model

representation of a real world object. example: student class is not a real student object. student class includes only name, surname, age and some others representation on digital world.

Model objemiz her zaman fiziksel bir nesneye tekab√ºl etmek zorunda deƒüil. Bazen "para transferi" gibi bir modelimizde olabilir.

## üìå domain model vs DB object

domain objeleri, DB objelerine benzer fakat DB objelerinden tamamiyle ayrƒ± olabilir. ilk uygulama tasarlandƒ±ƒüƒ±nda, "modeller" tasarlanmalƒ±dƒ±r. daha sonra database-admin bunlarƒ± nasƒ±l isterse o ≈üekilde DB'ye kaydeder. DB'de hƒ±zlƒ± arama olsun diye bazƒ± ≈üeyler denormalize edilebilir, sorgu bazlƒ± tablolar yapƒ±lmasƒ± i√ßin data'lar m√ºkerrer edilebilir vs... fakat bu optimizasyonlar DB objelerinde yapƒ±lmalƒ±dƒ±r.

dolayƒ±sƒ± ile; bu ikisi arasƒ±nda ger√ßek hayattaki nesneye/kavrama en benzer olan; domain objeleridir. √ß√ºnk√º DB y√∂neticileri ger√ßek hayata uzak deƒüi≈üiklikler yapabilir.

i≈üte DDD kitabƒ± bu '√ºn√ºn uygulamamƒ±zda birbirinden baƒüƒ±msƒ±z kalmasƒ±nƒ±, bu ≈üekilde DB yapƒ±sƒ±nƒ±n, domain modellerini veya i≈ü akƒ±≈üƒ±nƒ± etkilememesi konusunda y√∂nlendirmektedir.

## üìå domain model

domain model (class) is the model which is using by a domain.

## üìå DTO (‚ü∑ Data Transfer Object)

DTO is the class/structure which is using to store data. It can be using to send data from network protocols or passing arguments to functions. DTO can store model or models or any data...

ger√ßek bir uygulamadan √∂rnek verirsek; repository'den d√∂nen entity class'ƒ±, √∂nce model'e √ßevrilir, sonrada DTO'ya √ßevrilir ve client'a d√∂n√ºl√ºr.

DTO'lar, modellerimiz'in i√ßerikleri aynƒ± olacaklarƒ± anlamƒ±na gelmez. Farklƒ± da olabilirler. Yada aynƒ± olabilirler ama modelleri direk d√∂nd√ºrmek yerine, mapping yaparak aynƒ± field'lara sahip farklƒ± objeler de kullanabiliriz. √á√ºnk√º DTO'lar sadece Data transfer objeleridir ve servisler arasƒ± haberle≈üme'de data transferi i√ßin kullanƒ±rlar. Remote servis √ßaƒürƒ±larƒ± maliyetli olduƒüu i√ßin, tek bir istekte bir√ßok data'yƒ± birden ta≈üƒ±mak isteriz. Bu sebeple DTO' pattern'i ortaya atƒ±lmƒ±≈ütƒ±r. kaynak: (source-id: 234) 1st paragraph.

Sun/Java community DTO'lara sadece "transfer obje" demektedir. Bu pattern'in yazƒ±lƒ±m d√ºnyasƒ±nda genel adƒ± "Data Transfer Object (‚ü∑ DTO)"tir. kaynak: (source-id: 234) son paragraf.

## üìå entity

yazƒ±lƒ±m framework'lerinde "entity" terimi, DB'deki bir tablonun yazƒ±lƒ±m tarafƒ±ndaki temsilidir (√∂rnek JPA "entity bean"). fakat Eric'in DDD kitabƒ±nda "entity" terimi farklƒ± ama√ßla kullanƒ±lmaktadƒ±r. kaynak: "Eric Evans", "DDD", "Entities (a.k.a. Reference Objects)" ba≈ülƒ±ƒüƒ±, 13'√ºnc√º paragraf.

Eric'in kitapta bahsettiƒüi entity kavramƒ±; e≈üle≈ütirilmeye kalktƒ±ƒüƒ±mƒ±zda (bir e≈üitlik sorgusunda) field'larƒ± ile deƒüil, sadece ID'si ile kontrol etmemiz gereken domain modellerimizdir. kaynak: "Eric Evans", "DDD", "Entities (a.k.a. Reference Objects)" ba≈ülƒ±ƒüƒ±, 12'√ºnc√º paragrafƒ±n ilk c√ºmlesi.

Bazƒ± kaynaklarda DDD'den bahsedilsin veya bahsedilmesin, "entity" terimi direk olarak hem domain model, hem de DB nesnesinin yerine  kullanƒ±lmaktadƒ±r. Bunun 3 temel sebebi vardƒ±r:

1- domain model, BD'ye farklƒ± kaydedilse de, aslƒ±nda ikisi birbirinin yansƒ±masƒ±dƒ±r. Farklƒ± bir deƒüi≈ü ile; bir modelin DB'ye farklƒ± bir bi√ßimde kaydedilmi≈ü olmasƒ± (yansƒ±tƒ±lmƒ±≈ü olmasƒ±) onun ger√ßek deƒüerinin kaybolmasƒ±na sebep olmaz. √ñrneƒüin; aynƒ± modelin, "materialized view" ile NoSQL ve RDBMS'e ayrƒ± ayrƒ± kaydediliƒüini d√º≈ü√ºnelim. ƒ∞lgili model, DB-1, DB-2 arasƒ± mapper fonksiyonlarƒ±mƒ±z olsun. Aslƒ±nda 3'√º arasƒ±nda git gel yapabiliyoruz. Bu durumda aslƒ±nda 3 taraftaki data aslƒ±nda aynƒ± varlƒ±ƒüa tekab√ºl ediyor.

2- JPA direk olarak kendi i√ßinde bu terimi DDD'den baƒüƒ±msƒ±z ≈üekilde kullanmaktadƒ±r. Sadece DB tarafƒ±ndan bakƒ±ldƒ±ƒüƒ±nda her tablo birer 'varlƒ±k'tƒ±r.

3- DDD uygulamadƒ±ƒüƒ±mƒ±z sistemde, NoSQL tarzƒ± sistemler kullanmƒ±yorsak, genelde direk "entity bean" sƒ±nƒ±flarƒ±nƒ±, model olarak d√º≈ü√ºn√ºp birebir ≈üekilde kullanƒ±rƒ±z.

## üìå value object

- property'leri e≈üit olduƒüunda, birbirleri yerine kullanƒ±labilen objeler'dir.
- immutable olmalƒ±dƒ±rlar.

- A≈üaƒüƒ±da bazƒ± √∂rnekler listelendi. Fakat bu objeler domain'den domain'e (business logic'e g√∂re) entity veya value obje olabilirler. Yani a≈üaƒüƒ±dakiler bu ≈üekilde olacak diye bir kaide yoktur. A≈üaƒüƒ±dakiler Sadece √∂rnek ama√ßlƒ± yazƒ±lmƒ±≈ütƒ±r.

√∂rnek-1:

X ve Y DB objelerimiz olsun. ikisinin t√ºm property'lerinin (isim, soy isim, ya≈ü...) value'larƒ± aynƒ± olsun. buna raƒümen bu objeler birbirlerine e≈üit deƒüildir. √ß√ºnk√º ID'leri farklƒ±dƒ±r. bu sebeple bu objeler "value object" deƒüildir.

√∂rnek-2:

Koordinat d√ºzlemindeki noktayƒ± tutan bir point1 ve point2'miz olsun. bu objelerin property'leri (x, y, z) eƒüer aynƒ± ise bu 2 obje birbirlerine e≈üit demektedir. bu sebeple "point" objesi bir "value object" sƒ±nƒ±fƒ±na girer.

√∂rnek-3:

ƒ∞ki farklƒ± ki≈üi aynƒ± adres'te oturuyor olabilir. B√∂yle bir durumda her iki Person objesinin hangi adrese i≈üaret ettiƒüinin √∂nemi yoktur. Bu sebeple, adresin value object olmasƒ±nƒ± bekleriz. Fakat bazƒ± business'larda adres objelerinin birbirinin aynƒ±sƒ± olup olmayacaƒüƒ±nƒ± tanƒ±mlayan bir garanti olmayabiliyor. √á√ºnk√º adresler genelde manuel giri≈ü yapƒ±lƒ±yor. Son kullanƒ±cƒ± tarafƒ±ndan otomatik tamamlamadan se√ßilerek tanƒ±mlanmƒ±yor. Uzunca bir string oluyorlar. Bu durum genelde e-ticaret sitelerinde oluyor. Bu sebeple e-ticaret sitelerinde adres bir entity'dir.

Oysa bir harita sisteminde (√∂rnek: google maps) bir adresin neresi olduƒüu t√ºm field'larƒ± ile ayrƒ±lmƒ±≈ü ≈üekilde sistematik olarak tutulur. Bu sebeple google-maps i√ßin adres value objedir.

Not: E-ticaret platformlarƒ±ndaki adres objesinin entity olmasƒ±nƒ±n sebebi; son kullanƒ±cƒ± tarafƒ±ndan update edilebilmesi (yani immutable kuralƒ± bozmasƒ±) deƒüildir. √á√ºnk√º e-ticaret sitelerinde update edilen adres olduƒüunda, yeni bir adres objesi yaratƒ±lƒ±r ve eskisi disable edilir/edilebilir.

√∂rnek-4:

renkler birer value object'tir. kaynak: kaynak: "Eric Evans", "DDD", "Is "Address" a VALUE OBJECT? Who's Asking?" ba≈ülƒ±ƒüƒ±nƒ±n hemen sonrasƒ±ndaki ilk c√ºmle.

diƒüer √∂rnekler:

money, range, date birer value objedir.

## üìå strategic design vs tactical design

DDD kitabƒ± 2 temel kƒ±sƒ±mdan olu≈üuyor. ƒ∞√ßerdiƒüi bazƒ± konular a≈üaƒüƒ±daki gibidir:

- __tactical design__ (bu terim kitapta ge√ßmiyor. Piyasada kitabƒ±n bu kƒ±smƒ±na hitap edenler bu terimi kullanƒ±yor.)

  Kitabƒ±n "Part IV" b√∂l√ºm√ºnden √∂nceki t√ºm b√∂l√ºmlerini kapsƒ±yor.

  Daha √ßok kod (class) seviyesinde pattern'ler i√ßeriyor.

  - aggregate
  - value object
  - layered architecture
  - factories
  - repositories

- __strategic design__ (name of the "Part IV" of the book)

  Biraz daha b√ºy√ºk resimden bakmamƒ±zƒ± saƒülayan, √ßok a≈üƒ±rƒ± detaylar belirtilmediƒüi bir b√∂l√ºm burasƒ±. Daha √ßok domain'in nasƒ±l ayrƒ±lacaƒüƒ±nƒ± anlatmaya √ßalƒ±≈üƒ±lƒ±yor.

  - Bounded Context
  - Context Map
  - domain types (core-domain, sub-domain...)

Aslƒ±nda kitabƒ± bu ≈üekilde net olarak 2'ye b√∂lmek m√ºmk√ºn deƒüil. Birbirine baƒülƒ± √ßok konu var. √ñrneƒüin "Ubiquitous Language" konusu tactical'da anlatƒ±lƒ±yor. Fakat strategic'in altƒ±nda olmasƒ± daha doƒüru gibi. Zaten birindeki ibareler, diƒüerlerinin altyapƒ±sƒ±nƒ± hazƒ±rlƒ±yor...

Strateji ve taktik kelimelerinin kelime anlamlarƒ± i√ßin buradaki cevaplar okunabilir: <https://english.stackexchange.com/questions/29415/whats-the-difference-between-the-adjectives-strategic-and-tactical>
